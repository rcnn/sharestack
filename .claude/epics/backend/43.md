---
name: 视频处理系统
status: backlog
created: 2025-09-15T02:51:00Z
github: https://github.com/rcnn/sharestack/issues/43
depends_on: [001, 41]
parallel: true
conflicts_with: []
---

# Task: 视频处理系统

## Description

实现完整的视频处理系统，包括视频转码、压缩、缩略图生成、元数据提取、格式转换等功能。支持多种视频格式和质量优化。

## Acceptance Criteria

- [ ] 完成视频转码API (/api/v1/media/videos/transcode)
- [ ] 完成视频缩略图API (/api/v1/media/videos/thumbnail)
- [ ] 实现视频元数据提取功能
- [ ] 实现视频质量压缩
- [ ] 实现视频格式转换
- [ ] 实现视频切片和流媒体支持
- [ ] 实现批量视频处理
- [ ] 编写完整的测试用例

## Technical Details

### 视频处理引擎

#### 使用FFmpeg进行视频处理
```python
import subprocess
import json
import os
from pathlib import Path

class VideoProcessor:
    SUPPORTED_FORMATS = ['mp4', 'avi', 'mov', 'wmv', 'flv', 'webm', 'mkv']
    OUTPUT_FORMATS = ['mp4', 'webm', 'mov']

    def __init__(self):
        self.ffmpeg_path = self._find_ffmpeg()
        self.ffprobe_path = self._find_ffprobe()

    def transcode_video(self, input_path, output_path, quality='medium', format='mp4'):
        """视频转码"""
        quality_settings = {
            'low': {
                'video_bitrate': '500k',
                'audio_bitrate': '64k',
                'resolution': '480p',
                'crf': '28'
            },
            'medium': {
                'video_bitrate': '1500k',
                'audio_bitrate': '128k',
                'resolution': '720p',
                'crf': '23'
            },
            'high': {
                'video_bitrate': '3000k',
                'audio_bitrate': '192k',
                'resolution': '1080p',
                'crf': '18'
            }
        }

        settings = quality_settings.get(quality, quality_settings['medium'])

        cmd = [
            self.ffmpeg_path,
            '-i', input_path,
            '-c:v', 'libx264',
            '-crf', settings['crf'],
            '-preset', 'medium',
            '-c:a', 'aac',
            '-b:a', settings['audio_bitrate'],
            '-movflags', '+faststart',  # 优化在线播放
            '-y',  # 覆盖输出文件
            output_path
        ]

        # 如果指定了分辨率，添加缩放参数
        if settings.get('resolution'):
            if settings['resolution'] == '480p':
                cmd.extend(['-vf', 'scale=-2:480'])
            elif settings['resolution'] == '720p':
                cmd.extend(['-vf', 'scale=-2:720'])
            elif settings['resolution'] == '1080p':
                cmd.extend(['-vf', 'scale=-2:1080'])

        return self._run_ffmpeg_command(cmd)

    def generate_thumbnail(self, video_path, output_path, timestamp='00:00:01', size='320x240'):
        """生成视频缩略图"""
        cmd = [
            self.ffmpeg_path,
            '-i', video_path,
            '-ss', timestamp,  # 指定时间点
            '-vframes', '1',   # 只提取一帧
            '-vf', f'scale={size}',
            '-y',
            output_path
        ]

        return self._run_ffmpeg_command(cmd)

    def generate_multiple_thumbnails(self, video_path, output_dir, count=5):
        """生成多个缩略图"""
        duration = self.get_video_duration(video_path)
        if not duration:
            return []

        thumbnails = []
        interval = duration / (count + 1)

        for i in range(1, count + 1):
            timestamp = int(interval * i)
            timestamp_str = f'{timestamp // 3600:02d}:{(timestamp % 3600) // 60:02d}:{timestamp % 60:02d}'
            output_path = os.path.join(output_dir, f'thumb_{i}.jpg')

            if self.generate_thumbnail(video_path, output_path, timestamp_str):
                thumbnails.append(output_path)

        return thumbnails

    def extract_metadata(self, video_path):
        """提取视频元数据"""
        cmd = [
            self.ffprobe_path,
            '-v', 'quiet',
            '-print_format', 'json',
            '-show_format',
            '-show_streams',
            video_path
        ]

        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            metadata = json.loads(result.stdout)

            # 解析关键信息
            video_info = {}
            audio_info = {}

            for stream in metadata.get('streams', []):
                if stream.get('codec_type') == 'video':
                    video_info = {
                        'codec': stream.get('codec_name'),
                        'width': stream.get('width'),
                        'height': stream.get('height'),
                        'fps': eval(stream.get('r_frame_rate', '0/1')),
                        'bitrate': stream.get('bit_rate'),
                        'pixel_format': stream.get('pix_fmt')
                    }
                elif stream.get('codec_type') == 'audio':
                    audio_info = {
                        'codec': stream.get('codec_name'),
                        'sample_rate': stream.get('sample_rate'),
                        'channels': stream.get('channels'),
                        'bitrate': stream.get('bit_rate')
                    }

            format_info = metadata.get('format', {})

            return {
                'duration': float(format_info.get('duration', 0)),
                'size': int(format_info.get('size', 0)),
                'bitrate': format_info.get('bit_rate'),
                'format': format_info.get('format_name'),
                'video': video_info,
                'audio': audio_info,
                'raw_metadata': metadata
            }

        except subprocess.CalledProcessError as e:
            logger.error(f"提取视频元数据失败: {e}")
            return None

    def create_hls_playlist(self, video_path, output_dir, segment_duration=10):
        """创建HLS流媒体播放列表"""
        playlist_path = os.path.join(output_dir, 'playlist.m3u8')
        segment_pattern = os.path.join(output_dir, 'segment_%03d.ts')

        cmd = [
            self.ffmpeg_path,
            '-i', video_path,
            '-c:v', 'libx264',
            '-c:a', 'aac',
            '-hls_time', str(segment_duration),
            '-hls_playlist_type', 'vod',
            '-hls_segment_filename', segment_pattern,
            playlist_path
        ]

        if self._run_ffmpeg_command(cmd):
            return playlist_path
        return None

    def _run_ffmpeg_command(self, cmd):
        """执行FFmpeg命令"""
        try:
            process = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                check=True
            )
            return True
        except subprocess.CalledProcessError as e:
            logger.error(f"FFmpeg命令执行失败: {e.stderr}")
            return False

    def _find_ffmpeg(self):
        """查找FFmpeg可执行文件"""
        import shutil
        ffmpeg_path = shutil.which('ffmpeg')
        if not ffmpeg_path:
            raise RuntimeError("未找到FFmpeg，请确保已正确安装")
        return ffmpeg_path

    def _find_ffprobe(self):
        """查找FFprobe可执行文件"""
        import shutil
        ffprobe_path = shutil.which('ffprobe')
        if not ffprobe_path:
            raise RuntimeError("未找到FFprobe，请确保已正确安装")
        return ffprobe_path
```

### API接口实现

#### 视频处理接口
- **POST /api/v1/media/videos/transcode**
  - 请求参数:
    - file_id: 文件ID
    - quality: 质量等级 (low, medium, high)
    - format: 输出格式 (mp4, webm)
    - resolution: 分辨率 (480p, 720p, 1080p)
  - 响应: 202 Accepted + 任务ID

- **POST /api/v1/media/videos/thumbnail**
  - 请求参数:
    - file_id: 文件ID
    - timestamp: 时间点 (默认00:00:01)
    - size: 缩略图尺寸 (默认320x240)
    - count: 缩略图数量 (多张缩略图)
  - 响应: 201 Created + 缩略图信息

### 异步视频处理

```python
@celery.task(bind=True)
def process_video_task(self, file_id, operation, params, user_id):
    """异步视频处理任务"""
    try:
        # 更新任务状态
        self.update_state(state='PROGRESS', meta={'progress': 0, 'status': '开始处理'})

        # 获取文件信息
        file_record = MediaFileRepository.get_by_id(file_id)
        if not file_record:
            raise ValueError("文件不存在")

        processor = VideoProcessor()

        if operation == 'transcode':
            # 视频转码
            output_path = generate_output_path(file_record.filename, params.get('format', 'mp4'))

            self.update_state(state='PROGRESS', meta={'progress': 20, 'status': '开始转码'})

            success = processor.transcode_video(
                file_record.file_path,
                output_path,
                quality=params.get('quality', 'medium'),
                format=params.get('format', 'mp4')
            )

            if success:
                # 保存转码后的文件记录
                new_file_record = MediaFileService.create_processed_file(
                    output_path, file_record, user_id
                )

                self.update_state(state='SUCCESS', meta={
                    'progress': 100,
                    'status': '转码完成',
                    'file_id': new_file_record.id,
                    'file_url': new_file_record.cdn_url
                })

                return {'status': 'success', 'file_id': new_file_record.id}
            else:
                raise RuntimeError("视频转码失败")

        elif operation == 'thumbnail':
            # 生成缩略图
            self.update_state(state='PROGRESS', meta={'progress': 30, 'status': '生成缩略图'})

            if params.get('count', 1) > 1:
                # 生成多张缩略图
                output_dir = create_temp_directory()
                thumbnails = processor.generate_multiple_thumbnails(
                    file_record.file_path,
                    output_dir,
                    count=params.get('count', 5)
                )

                thumbnail_records = []
                for thumb_path in thumbnails:
                    thumb_record = MediaFileService.create_thumbnail_record(
                        thumb_path, file_record, user_id
                    )
                    thumbnail_records.append(thumb_record)

                self.update_state(state='SUCCESS', meta={
                    'progress': 100,
                    'status': '缩略图生成完成',
                    'thumbnails': [t.id for t in thumbnail_records]
                })

                return {'status': 'success', 'thumbnails': thumbnail_records}
            else:
                # 生成单张缩略图
                output_path = generate_thumbnail_path(file_record.filename)
                success = processor.generate_thumbnail(
                    file_record.file_path,
                    output_path,
                    timestamp=params.get('timestamp', '00:00:01'),
                    size=params.get('size', '320x240')
                )

                if success:
                    thumb_record = MediaFileService.create_thumbnail_record(
                        output_path, file_record, user_id
                    )

                    self.update_state(state='SUCCESS', meta={
                        'progress': 100,
                        'status': '缩略图生成完成',
                        'thumbnail_id': thumb_record.id
                    })

                    return {'status': 'success', 'thumbnail_id': thumb_record.id}

    except Exception as e:
        logger.error(f"视频处理任务失败: {str(e)}")
        self.update_state(state='FAILURE', meta={'error': str(e)})
        raise
```

### 视频流媒体支持

```python
class StreamingService:
    def create_adaptive_streams(self, video_path, output_dir):
        """创建自适应流媒体"""
        processor = VideoProcessor()

        # 创建不同质量的视频流
        qualities = [
            {'name': '360p', 'resolution': '640x360', 'bitrate': '800k'},
            {'name': '480p', 'resolution': '854x480', 'bitrate': '1200k'},
            {'name': '720p', 'resolution': '1280x720', 'bitrate': '2500k'},
            {'name': '1080p', 'resolution': '1920x1080', 'bitrate': '4500k'}
        ]

        streams = []
        for quality in qualities:
            quality_dir = os.path.join(output_dir, quality['name'])
            os.makedirs(quality_dir, exist_ok=True)

            playlist_path = processor.create_quality_stream(
                video_path,
                quality_dir,
                quality['resolution'],
                quality['bitrate']
            )

            if playlist_path:
                streams.append({
                    'quality': quality['name'],
                    'playlist': playlist_path,
                    'bitrate': quality['bitrate']
                })

        # 创建主播放列表
        master_playlist = self.create_master_playlist(streams, output_dir)
        return master_playlist

    def create_master_playlist(self, streams, output_dir):
        """创建主播放列表"""
        master_path = os.path.join(output_dir, 'master.m3u8')

        with open(master_path, 'w') as f:
            f.write('#EXTM3U\n')
            f.write('#EXT-X-VERSION:3\n\n')

            for stream in streams:
                bitrate = int(stream['bitrate'].replace('k', '')) * 1000
                f.write(f'#EXT-X-STREAM-INF:BANDWIDTH={bitrate}\n')
                f.write(f"{stream['quality']}/playlist.m3u8\n\n")

        return master_path
```

## Dependencies

- [ ] Task 001: 后端基础架构
- [ ] Task 020: 文件上传系统
- [ ] FFmpeg视频处理工具
- [ ] Celery异步任务处理

## Effort Estimate

- Size: XL
- Hours: 28小时
- Parallel: true

## Definition of Done

- [ ] 所有视频处理API接口实现完成
- [ ] 视频转码功能正常工作
- [ ] 缩略图生成功能正常
- [ ] 视频元数据提取准确
- [ ] 流媒体支持功能正常
- [ ] 异步任务处理稳定
- [ ] 视频处理性能满足要求
- [ ] 单元测试覆盖率达到90%
- [ ] API文档更新完成

## Implementation Notes

### Service层设计
```python
class VideoProcessingService:
    def transcode_video(self, file_id, params, user_id):
        """启动视频转码任务"""
        pass

    def generate_thumbnail(self, file_id, params, user_id):
        """生成视频缩略图"""
        pass

    def extract_metadata(self, file_id, user_id):
        """提取视频元数据"""
        pass

    def create_streaming_version(self, file_id, user_id):
        """创建流媒体版本"""
        pass

    def get_processing_status(self, task_id):
        """获取处理状态"""
        pass
```

### 错误处理
- 415: 不支持的视频格式
- 422: 视频参数无效
- 500: 视频处理失败
- 507: 存储空间不足

### 性能优化
- 分布式视频处理
- 处理结果缓存
- CDN加速播放
- 预处理热门视频