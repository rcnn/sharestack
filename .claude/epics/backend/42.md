---
name: 图片处理系统
status: backlog
created: 2025-09-15T02:51:00Z
github: https://github.com/rcnn/sharestack/issues/42
depends_on: [001, 41]
parallel: true
conflicts_with: []
---

# Task: 图片处理系统

## Description

实现完整的图片处理系统，包括图片压缩、缩放、格式转换、质量优化、水印添加等功能。为平台提供高效的图片处理和优化服务。

## Acceptance Criteria

- [ ] 完成图片压缩API (/api/v1/media/images/compress)
- [ ] 完成图片缩放API (/api/v1/media/images/resize)
- [ ] 实现图片格式转换功能
- [ ] 实现图片质量优化
- [ ] 实现图片水印添加
- [ ] 实现批量图片处理
- [ ] 实现图片元数据提取
- [ ] 编写完整的测试用例

## Technical Details

### 图片处理引擎

#### 使用Pillow进行图片处理
```python
from PIL import Image, ImageEnhance, ImageFilter
import io

class ImageProcessor:
    SUPPORTED_FORMATS = ['JPEG', 'PNG', 'GIF', 'WEBP', 'BMP']
    MAX_DIMENSIONS = (4096, 4096)

    def compress_image(self, image_path, quality=85, optimize=True):
        """图片压缩"""
        with Image.open(image_path) as img:
            # 转换为RGB模式（如果需要）
            if img.mode in ('RGBA', 'LA', 'P'):
                img = img.convert('RGB')

            # 压缩保存
            output = io.BytesIO()
            img.save(output, format='JPEG', quality=quality, optimize=optimize)
            return output.getvalue()

    def resize_image(self, image_path, width=None, height=None, keep_aspect=True):
        """图片缩放"""
        with Image.open(image_path) as img:
            original_width, original_height = img.size

            if keep_aspect:
                # 保持纵横比
                if width and height:
                    ratio = min(width/original_width, height/original_height)
                elif width:
                    ratio = width / original_width
                elif height:
                    ratio = height / original_height
                else:
                    return img

                new_size = (int(original_width * ratio), int(original_height * ratio))
            else:
                new_size = (width or original_width, height or original_height)

            # 使用高质量重采样
            resized = img.resize(new_size, Image.Resampling.LANCZOS)
            return resized

    def convert_format(self, image_path, target_format='WEBP'):
        """图片格式转换"""
        with Image.open(image_path) as img:
            if target_format not in self.SUPPORTED_FORMATS:
                raise ValueError(f"不支持的格式: {target_format}")

            # 处理透明度
            if target_format == 'JPEG' and img.mode in ('RGBA', 'LA'):
                # JPEG不支持透明度，添加白色背景
                background = Image.new('RGB', img.size, (255, 255, 255))
                background.paste(img, mask=img.split()[-1] if img.mode == 'RGBA' else None)
                img = background

            output = io.BytesIO()
            img.save(output, format=target_format, quality=90, optimize=True)
            return output.getvalue()
```

### API接口实现

#### 图片处理接口
- **POST /api/v1/media/images/compress**
  - 请求参数:
    - file_id: 文件ID
    - quality: 压缩质量 (1-100, 默认85)
    - optimize: 是否优化 (默认true)
  - 响应: 200 OK + 压缩后图片信息

- **POST /api/v1/media/images/resize**
  - 请求参数:
    - file_id: 文件ID
    - width: 目标宽度 (可选)
    - height: 目标高度 (可选)
    - keep_aspect: 保持纵横比 (默认true)
  - 响应: 200 OK + 缩放后图片信息

- **POST /api/v1/media/images/convert**
  - 请求参数:
    - file_id: 文件ID
    - target_format: 目标格式 (JPEG, PNG, WEBP等)
  - 响应: 200 OK + 转换后图片信息

### 图片水印系统

```python
class WatermarkService:
    def add_text_watermark(self, image_path, text, position='bottom-right', opacity=128):
        """添加文字水印"""
        with Image.open(image_path) as img:
            # 创建水印图层
            watermark = Image.new('RGBA', img.size, (0, 0, 0, 0))
            draw = ImageDraw.Draw(watermark)

            # 设置字体
            font_size = min(img.size) // 20  # 动态字体大小
            font = ImageFont.truetype("/path/to/font.ttf", font_size)

            # 计算文字位置
            text_bbox = draw.textbbox((0, 0), text, font=font)
            text_width = text_bbox[2] - text_bbox[0]
            text_height = text_bbox[3] - text_bbox[1]

            positions = {
                'top-left': (10, 10),
                'top-right': (img.width - text_width - 10, 10),
                'bottom-left': (10, img.height - text_height - 10),
                'bottom-right': (img.width - text_width - 10, img.height - text_height - 10),
                'center': ((img.width - text_width) // 2, (img.height - text_height) // 2)
            }

            pos = positions.get(position, positions['bottom-right'])

            # 绘制水印
            draw.text(pos, text, font=font, fill=(255, 255, 255, opacity))

            # 合并图片
            watermarked = Image.alpha_composite(img.convert('RGBA'), watermark)
            return watermarked.convert('RGB')

    def add_image_watermark(self, image_path, watermark_path, position='bottom-right', opacity=128):
        """添加图片水印"""
        with Image.open(image_path) as img, Image.open(watermark_path) as watermark:
            # 调整水印大小
            watermark_size = (min(img.size) // 4, min(img.size) // 4)
            watermark = watermark.resize(watermark_size, Image.Resampling.LANCZOS)

            # 设置透明度
            if watermark.mode != 'RGBA':
                watermark = watermark.convert('RGBA')

            alpha = watermark.split()[-1]
            alpha = alpha.point(lambda p: int(p * (opacity / 255.0)))
            watermark.putalpha(alpha)

            # 计算位置
            positions = {
                'top-left': (10, 10),
                'top-right': (img.width - watermark.width - 10, 10),
                'bottom-left': (10, img.height - watermark.height - 10),
                'bottom-right': (img.width - watermark.width - 10, img.height - watermark.height - 10),
                'center': ((img.width - watermark.width) // 2, (img.height - watermark.height) // 2)
            }

            pos = positions.get(position, positions['bottom-right'])

            # 合并图片
            img_rgba = img.convert('RGBA')
            img_rgba.paste(watermark, pos, watermark)
            return img_rgba.convert('RGB')
```

### 图片元数据提取

```python
from PIL.ExifTags import TAGS
import piexif

class ImageMetadataExtractor:
    def extract_metadata(self, image_path):
        """提取图片元数据"""
        metadata = {}

        with Image.open(image_path) as img:
            # 基本信息
            metadata.update({
                'format': img.format,
                'mode': img.mode,
                'size': img.size,
                'width': img.width,
                'height': img.height,
                'file_size': os.path.getsize(image_path)
            })

            # EXIF信息
            if hasattr(img, '_getexif'):
                exif_data = img._getexif()
                if exif_data:
                    exif_dict = {}
                    for tag_id, value in exif_data.items():
                        tag = TAGS.get(tag_id, tag_id)
                        exif_dict[tag] = value
                    metadata['exif'] = exif_dict

            # 色彩信息
            if img.mode == 'RGB':
                metadata['color_profile'] = 'RGB'
            elif img.mode == 'CMYK':
                metadata['color_profile'] = 'CMYK'

            # 计算文件哈希
            img.seek(0)
            file_hash = hashlib.md5(img.tobytes()).hexdigest()
            metadata['image_hash'] = file_hash

        return metadata
```

### 批量处理系统

```python
@celery.task
def batch_process_images(file_ids, operations, user_id):
    """批量处理图片"""
    results = []

    for file_id in file_ids:
        try:
            file_record = MediaFileRepository.get_by_id(file_id)
            if not file_record or file_record.uploaded_by != user_id:
                results.append({'file_id': file_id, 'status': 'error', 'message': '文件不存在或无权限'})
                continue

            processed_file = None
            for operation in operations:
                if operation['type'] == 'compress':
                    processed_file = ImageProcessor.compress_image(
                        file_record.file_path,
                        quality=operation.get('quality', 85)
                    )
                elif operation['type'] == 'resize':
                    processed_file = ImageProcessor.resize_image(
                        file_record.file_path,
                        width=operation.get('width'),
                        height=operation.get('height')
                    )
                elif operation['type'] == 'convert':
                    processed_file = ImageProcessor.convert_format(
                        file_record.file_path,
                        target_format=operation.get('format', 'WEBP')
                    )

            if processed_file:
                # 保存处理后的文件
                new_filename = f"processed_{file_record.filename}"
                new_file_record = MediaFileService.save_processed_file(
                    processed_file, new_filename, user_id, file_record.content_id
                )
                results.append({'file_id': file_id, 'status': 'success', 'new_file_id': new_file_record.id})
            else:
                results.append({'file_id': file_id, 'status': 'error', 'message': '处理失败'})

        except Exception as e:
            logger.error(f"批量处理图片失败: {str(e)}")
            results.append({'file_id': file_id, 'status': 'error', 'message': str(e)})

    return results
```

## Dependencies

- [ ] Task 001: 后端基础架构
- [ ] Task 020: 文件上传系统
- [ ] Pillow图像处理库
- [ ] Celery异步任务处理

## Effort Estimate

- Size: L
- Hours: 20小时
- Parallel: true

## Definition of Done

- [ ] 所有图片处理API接口实现完成
- [ ] 图片压缩和缩放功能正常
- [ ] 图片格式转换功能正常
- [ ] 水印系统功能完整
- [ ] 批量处理功能正常
- [ ] 图片处理性能满足要求 (普通图片<3s)
- [ ] 单元测试覆盖率达到90%
- [ ] API文档更新完成

## Implementation Notes

### Service层设计
```python
class ImageProcessingService:
    def compress_image(self, file_id, quality, user_id):
        """压缩图片"""
        pass

    def resize_image(self, file_id, dimensions, user_id):
        """缩放图片"""
        pass

    def convert_format(self, file_id, target_format, user_id):
        """转换格式"""
        pass

    def add_watermark(self, file_id, watermark_config, user_id):
        """添加水印"""
        pass

    def batch_process(self, file_ids, operations, user_id):
        """批量处理"""
        pass
```

### 缓存策略
- `image:metadata:{id}`: 图片元数据缓存 (TTL: 24小时)
- `image:processed:{hash}`: 处理结果缓存 (TTL: 7天)
- `image:thumbnail:{id}`: 缩略图缓存 (TTL: 30天)

### 性能优化
- 图片处理结果缓存
- 缩略图预生成
- CDN加速访问
- 异步批量处理

### 错误处理
- 400: 图片参数无效
- 415: 不支持的图片格式
- 422: 图片尺寸超限
- 500: 图片处理失败