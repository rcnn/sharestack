---
name: 媒体文件管理
status: backlog
created: 2025-09-15T02:51:00Z
github: https://github.com/rcnn/sharestack/issues/45
depends_on: [001, 41]
parallel: true
conflicts_with: []
---

# Task: 媒体文件管理

## Description

实现完整的媒体文件管理系统，包括文件列表、删除、整理、存储空间管理、文件分类、批量操作等功能。为用户提供便捷的媒体资源管理体验。

## Acceptance Criteria

- [ ] 完成文件列表API (/api/v1/media/list)
- [ ] 完成文件删除API (/api/v1/media/delete)
- [ ] 完成文件整理API (/api/v1/media/organize)
- [ ] 实现存储空间管理功能
- [ ] 实现文件分类和标签管理
- [ ] 实现批量文件操作
- [ ] 实现文件搜索和过滤
- [ ] 编写完整的测试用例

## Technical Details

### 文件管理数据模型扩展

#### Media_Folders文件夹表
```sql
CREATE TABLE media_folders (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    parent_id BIGINT NULL,
    user_id BIGINT NOT NULL,
    folder_type ENUM('user', 'system', 'shared') DEFAULT 'user',
    is_public BOOLEAN DEFAULT FALSE,
    sort_order INT DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL,
    INDEX idx_user_id (user_id),
    INDEX idx_parent_id (parent_id),
    INDEX idx_folder_type (folder_type),
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (parent_id) REFERENCES media_folders(id)
);
```

#### 扩展Media_Files表
```sql
ALTER TABLE media_files ADD COLUMN (
    folder_id BIGINT NULL,
    tags JSON,
    description TEXT,
    alt_text VARCHAR(255), -- 图片替代文本
    copyright_info VARCHAR(255),
    usage_count INT DEFAULT 0,
    last_accessed_at TIMESTAMP NULL,
    is_favorite BOOLEAN DEFAULT FALSE,
    INDEX idx_folder_id (folder_id),
    INDEX idx_usage_count (usage_count),
    INDEX idx_is_favorite (is_favorite),
    FOREIGN KEY (folder_id) REFERENCES media_folders(id)
);
```

#### User_Storage_Quota存储配额表
```sql
CREATE TABLE user_storage_quota (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL UNIQUE,
    total_quota BIGINT NOT NULL DEFAULT 1073741824, -- 1GB默认配额
    used_space BIGINT DEFAULT 0,
    file_count INT DEFAULT 0,
    quota_type ENUM('free', 'premium', 'enterprise') DEFAULT 'free',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_quota_type (quota_type),
    FOREIGN KEY (user_id) REFERENCES users(id)
);
```

### API接口规范

#### 文件管理接口
- **GET /api/v1/media/list**
  - 查询参数:
    - folder_id: 文件夹ID (可选)
    - file_type: 文件类型过滤
    - page, page_size: 分页参数
    - sort_by: 排序字段 (name, size, created_at, usage_count)
    - sort_order: 排序方向 (asc, desc)
    - search: 搜索关键词
    - tags: 标签过滤
  - 响应: 200 OK + 文件列表

- **DELETE /api/v1/media/{id}/delete**
  - 删除指定文件
  - 查询参数: force (是否强制删除，跳过回收站)
  - 响应: 204 No Content

- **POST /api/v1/media/batch-delete**
  - 请求体: file_ids (文件ID数组)
  - 批量删除文件
  - 响应: 200 OK + 删除结果

#### 文件夹管理接口
- **GET /api/v1/media/folders**
  - 获取用户文件夹列表
  - 查询参数: parent_id, include_files
  - 响应: 200 OK + 文件夹树结构

- **POST /api/v1/media/folders**
  - 请求体: name, description, parent_id
  - 创建新文件夹
  - 响应: 201 Created + 文件夹信息

- **PUT /api/v1/media/folders/{id}**
  - 更新文件夹信息
  - 请求体: name, description, parent_id
  - 响应: 200 OK + 更新后信息

#### 文件整理接口
- **POST /api/v1/media/organize**
  - 请求体: file_ids, target_folder_id, operation (move, copy)
  - 移动或复制文件到指定文件夹
  - 响应: 200 OK + 操作结果

- **POST /api/v1/media/{id}/favorite**
  - 收藏/取消收藏文件
  - 响应: 200 OK + 收藏状态

### 存储空间管理

```python
class StorageQuotaService:
    def get_user_quota(self, user_id):
        """获取用户存储配额信息"""
        quota = UserStorageQuotaRepository.get_by_user_id(user_id)
        if not quota:
            # 创建默认配额
            quota = self.create_default_quota(user_id)

        return {
            'total_quota': quota.total_quota,
            'used_space': quota.used_space,
            'available_space': quota.total_quota - quota.used_space,
            'file_count': quota.file_count,
            'usage_percentage': (quota.used_space / quota.total_quota) * 100,
            'quota_type': quota.quota_type
        }

    def check_upload_quota(self, user_id, file_size):
        """检查上传是否超出配额"""
        quota = self.get_user_quota(user_id)

        if quota['used_space'] + file_size > quota['total_quota']:
            return {
                'allowed': False,
                'reason': 'storage_quota_exceeded',
                'available_space': quota['available_space']
            }

        return {'allowed': True}

    def update_quota_usage(self, user_id, size_delta, file_count_delta=0):
        """更新配额使用量"""
        quota = UserStorageQuotaRepository.get_by_user_id(user_id)
        if quota:
            quota.used_space += size_delta
            quota.file_count += file_count_delta
            UserStorageQuotaRepository.update(quota)

    def upgrade_quota(self, user_id, new_quota_type):
        """升级用户配额"""
        quota_limits = {
            'free': 1 * 1024 * 1024 * 1024,      # 1GB
            'premium': 10 * 1024 * 1024 * 1024,   # 10GB
            'enterprise': 100 * 1024 * 1024 * 1024 # 100GB
        }

        new_quota = quota_limits.get(new_quota_type)
        if not new_quota:
            raise ValueError("无效的配额类型")

        quota = UserStorageQuotaRepository.get_by_user_id(user_id)
        quota.quota_type = new_quota_type
        quota.total_quota = new_quota
        UserStorageQuotaRepository.update(quota)

        return self.get_user_quota(user_id)
```

### 文件搜索和过滤

```python
class MediaSearchService:
    def search_files(self, user_id, query_params):
        """搜索用户文件"""
        filters = self._build_search_filters(user_id, query_params)

        # 基础查询
        query = MediaFileRepository.query().filter(
            MediaFile.uploaded_by == user_id,
            MediaFile.deleted_at.is_(None)
        )

        # 应用过滤条件
        if filters.get('search'):
            search_term = f"%{filters['search']}%"
            query = query.filter(
                or_(
                    MediaFile.filename.like(search_term),
                    MediaFile.original_filename.like(search_term),
                    MediaFile.description.like(search_term)
                )
            )

        if filters.get('file_type'):
            query = query.filter(MediaFile.file_type == filters['file_type'])

        if filters.get('folder_id'):
            query = query.filter(MediaFile.folder_id == filters['folder_id'])

        if filters.get('tags'):
            # JSON数组查询
            for tag in filters['tags']:
                query = query.filter(
                    MediaFile.tags.contains([tag])
                )

        if filters.get('date_range'):
            start_date = filters['date_range'].get('start')
            end_date = filters['date_range'].get('end')
            if start_date:
                query = query.filter(MediaFile.created_at >= start_date)
            if end_date:
                query = query.filter(MediaFile.created_at <= end_date)

        if filters.get('size_range'):
            min_size = filters['size_range'].get('min')
            max_size = filters['size_range'].get('max')
            if min_size:
                query = query.filter(MediaFile.file_size >= min_size)
            if max_size:
                query = query.filter(MediaFile.file_size <= max_size)

        # 排序
        sort_by = filters.get('sort_by', 'created_at')
        sort_order = filters.get('sort_order', 'desc')

        if sort_order == 'desc':
            query = query.order_by(desc(getattr(MediaFile, sort_by)))
        else:
            query = query.order_by(asc(getattr(MediaFile, sort_by)))

        # 分页
        page = filters.get('page', 1)
        page_size = filters.get('page_size', 20)

        return query.paginate(page=page, per_page=page_size)

    def _build_search_filters(self, user_id, query_params):
        """构建搜索过滤器"""
        filters = {}

        # 文本搜索
        if query_params.get('search'):
            filters['search'] = query_params['search']

        # 文件类型过滤
        if query_params.get('file_type'):
            filters['file_type'] = query_params['file_type']

        # 文件夹过滤
        if query_params.get('folder_id'):
            filters['folder_id'] = int(query_params['folder_id'])

        # 标签过滤
        if query_params.get('tags'):
            if isinstance(query_params['tags'], str):
                filters['tags'] = query_params['tags'].split(',')
            else:
                filters['tags'] = query_params['tags']

        # 日期范围过滤
        if query_params.get('start_date') or query_params.get('end_date'):
            filters['date_range'] = {}
            if query_params.get('start_date'):
                filters['date_range']['start'] = datetime.fromisoformat(
                    query_params['start_date']
                )
            if query_params.get('end_date'):
                filters['date_range']['end'] = datetime.fromisoformat(
                    query_params['end_date']
                )

        # 文件大小过滤
        if query_params.get('min_size') or query_params.get('max_size'):
            filters['size_range'] = {}
            if query_params.get('min_size'):
                filters['size_range']['min'] = int(query_params['min_size'])
            if query_params.get('max_size'):
                filters['size_range']['max'] = int(query_params['max_size'])

        # 排序参数
        filters['sort_by'] = query_params.get('sort_by', 'created_at')
        filters['sort_order'] = query_params.get('sort_order', 'desc')
        filters['page'] = int(query_params.get('page', 1))
        filters['page_size'] = min(int(query_params.get('page_size', 20)), 100)

        return filters
```

### 批量操作系统

```python
class MediaBatchService:
    def batch_organize(self, file_ids, target_folder_id, operation, user_id):
        """批量整理文件"""
        results = []

        for file_id in file_ids:
            try:
                file_record = MediaFileRepository.get_by_id(file_id)
                if not file_record or file_record.uploaded_by != user_id:
                    results.append({
                        'file_id': file_id,
                        'status': 'error',
                        'message': '文件不存在或无权限'
                    })
                    continue

                if operation == 'move':
                    file_record.folder_id = target_folder_id
                    MediaFileRepository.update(file_record)
                    results.append({
                        'file_id': file_id,
                        'status': 'success',
                        'operation': 'moved'
                    })

                elif operation == 'copy':
                    # 复制文件记录
                    new_file = self._copy_file_record(file_record, target_folder_id)
                    results.append({
                        'file_id': file_id,
                        'status': 'success',
                        'operation': 'copied',
                        'new_file_id': new_file.id
                    })

            except Exception as e:
                logger.error(f"批量操作文件失败: {str(e)}")
                results.append({
                    'file_id': file_id,
                    'status': 'error',
                    'message': str(e)
                })

        return results

    def batch_tag(self, file_ids, tags, operation, user_id):
        """批量标签操作"""
        results = []

        for file_id in file_ids:
            try:
                file_record = MediaFileRepository.get_by_id(file_id)
                if not file_record or file_record.uploaded_by != user_id:
                    results.append({
                        'file_id': file_id,
                        'status': 'error',
                        'message': '文件不存在或无权限'
                    })
                    continue

                current_tags = file_record.tags or []

                if operation == 'add':
                    # 添加标签
                    new_tags = list(set(current_tags + tags))
                    file_record.tags = new_tags
                elif operation == 'remove':
                    # 移除标签
                    new_tags = [tag for tag in current_tags if tag not in tags]
                    file_record.tags = new_tags
                elif operation == 'replace':
                    # 替换标签
                    file_record.tags = tags

                MediaFileRepository.update(file_record)
                results.append({
                    'file_id': file_id,
                    'status': 'success',
                    'tags': file_record.tags
                })

            except Exception as e:
                logger.error(f"批量标签操作失败: {str(e)}")
                results.append({
                    'file_id': file_id,
                    'status': 'error',
                    'message': str(e)
                })

        return results

    def _copy_file_record(self, original_file, target_folder_id):
        """复制文件记录"""
        # 这里只复制数据库记录，不复制实际文件
        new_file_data = {
            'filename': f"copy_of_{original_file.filename}",
            'original_filename': original_file.original_filename,
            'file_path': original_file.file_path,
            'file_size': original_file.file_size,
            'file_type': original_file.file_type,
            'mime_type': original_file.mime_type,
            'file_extension': original_file.file_extension,
            'file_hash': original_file.file_hash,
            'uploaded_by': original_file.uploaded_by,
            'folder_id': target_folder_id,
            'storage_provider': original_file.storage_provider,
            'storage_path': original_file.storage_path,
            'cdn_url': original_file.cdn_url,
            'metadata': original_file.metadata,
            'is_public': original_file.is_public
        }

        return MediaFileRepository.create(new_file_data)
```

### 文件清理和回收站

```python
class MediaCleanupService:
    def soft_delete_file(self, file_id, user_id):
        """软删除文件（移到回收站）"""
        file_record = MediaFileRepository.get_by_id(file_id)
        if not file_record or file_record.uploaded_by != user_id:
            raise PermissionError("无权限删除此文件")

        file_record.deleted_at = datetime.now()
        MediaFileRepository.update(file_record)

        # 更新用户配额（从使用量中减去）
        StorageQuotaService.update_quota_usage(
            user_id, -file_record.file_size, -1
        )

    def restore_file(self, file_id, user_id):
        """从回收站恢复文件"""
        file_record = MediaFileRepository.get_by_id(file_id)
        if not file_record or file_record.uploaded_by != user_id:
            raise PermissionError("无权限恢复此文件")

        # 检查配额
        quota_check = StorageQuotaService.check_upload_quota(
            user_id, file_record.file_size
        )
        if not quota_check['allowed']:
            raise QuotaExceededError("存储空间不足，无法恢复文件")

        file_record.deleted_at = None
        MediaFileRepository.update(file_record)

        # 更新用户配额
        StorageQuotaService.update_quota_usage(
            user_id, file_record.file_size, 1
        )

    def permanent_delete_file(self, file_id, user_id):
        """永久删除文件"""
        file_record = MediaFileRepository.get_by_id(file_id)
        if not file_record or file_record.uploaded_by != user_id:
            raise PermissionError("无权限删除此文件")

        # 删除物理文件
        try:
            storage_manager = StorageManager()
            storage_manager.delete_file(
                file_record.file_path,
                file_record.storage_provider
            )
        except Exception as e:
            logger.error(f"删除物理文件失败: {str(e)}")

        # 删除数据库记录
        MediaFileRepository.delete(file_id)

    @celery.task
    def cleanup_old_deleted_files():
        """清理超过30天的已删除文件"""
        cutoff_date = datetime.now() - timedelta(days=30)

        old_deleted_files = MediaFileRepository.get_deleted_before(cutoff_date)

        for file_record in old_deleted_files:
            try:
                MediaCleanupService.permanent_delete_file(
                    file_record.id, file_record.uploaded_by
                )
                logger.info(f"已清理过期文件: {file_record.filename}")
            except Exception as e:
                logger.error(f"清理过期文件失败: {str(e)}")
```

## Dependencies

- [ ] Task 001: 后端基础架构
- [ ] Task 020: 文件上传系统
- [ ] 用户管理模块 (权限验证)
- [ ] Celery异步任务处理

## Effort Estimate

- Size: L
- Hours: 20小时
- Parallel: true

## Definition of Done

- [ ] 所有媒体文件管理API接口实现完成
- [ ] 文件夹管理功能正常
- [ ] 存储配额管理准确
- [ ] 文件搜索和过滤功能完整
- [ ] 批量操作功能稳定
- [ ] 回收站功能正常
- [ ] 存储性能满足要求
- [ ] 单元测试覆盖率达到90%
- [ ] API文档更新完成

## Implementation Notes

### Service层设计
```python
class MediaManagementService:
    def list_files(self, user_id, filters):
        """列出文件"""
        pass

    def organize_files(self, file_ids, operation, user_id):
        """整理文件"""
        pass

    def manage_folders(self, folder_data, user_id):
        """管理文件夹"""
        pass

    def get_storage_info(self, user_id):
        """获取存储信息"""
        pass
```

### 缓存策略
- `media:list:{user_id}:{hash}`: 文件列表缓存 (TTL: 30分钟)
- `media:folder:{id}`: 文件夹信息缓存 (TTL: 1小时)
- `storage:quota:{user_id}`: 存储配额缓存 (TTL: 15分钟)

### 性能优化
- 文件列表分页优化
- 批量操作事务处理
- 存储统计数据缓存
- 定期数据清理任务

### 错误处理
- 404: 文件或文件夹不存在
- 403: 权限不足
- 507: 存储空间不足
- 409: 文件夹名称冲突