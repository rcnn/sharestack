---
name: 内容版本控制系统
status: backlog
created: 2025-09-15T02:51:00Z
github: https://github.com/rcnn/sharestack/issues/39
depends_on: [001, 34]
parallel: true
conflicts_with: []
---

# Task: 内容版本控制系统

## Description

实现内容的版本管理功能，包括版本创建、历史查询、版本回退、版本对比等功能。支持内容的完整变更历史记录和恢复。

## Acceptance Criteria

- [ ] 完成版本管理API (/api/v1/contents/{id}/versions)
- [ ] 完成版本回退API (/api/v1/contents/{id}/revert)
- [ ] 完成版本对比API (/api/v1/contents/{id}/compare)
- [ ] 实现自动版本创建机制
- [ ] 实现变更历史记录
- [ ] 实现版本对比算法
- [ ] 实现版本清理机制
- [ ] 编写完整的测试用例

## Technical Details

### 版本数据模型设计

#### Content_Versions版本表
```sql
CREATE TABLE content_versions (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    content_id BIGINT NOT NULL,
    version_number INT NOT NULL,
    title VARCHAR(200) NOT NULL,
    content TEXT,
    summary VARCHAR(500),
    content_type ENUM('article', 'video', 'audio', 'document') NOT NULL,
    metadata JSON, -- 其他元数据存储
    change_type ENUM('create', 'update', 'publish', 'revert') NOT NULL,
    change_summary VARCHAR(255), -- 变更摘要
    changed_by BIGINT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    file_size BIGINT DEFAULT 0, -- 内容大小
    INDEX idx_content_id (content_id),
    INDEX idx_version_number (version_number),
    INDEX idx_created_at (created_at),
    INDEX idx_changed_by (changed_by),
    UNIQUE KEY unique_content_version (content_id, version_number),
    FOREIGN KEY (content_id) REFERENCES contents(id) ON DELETE CASCADE,
    FOREIGN KEY (changed_by) REFERENCES users(id)
);
```

#### Content_Diffs变更差异表
```sql
CREATE TABLE content_diffs (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    content_id BIGINT NOT NULL,
    from_version INT NOT NULL,
    to_version INT NOT NULL,
    field_name VARCHAR(50) NOT NULL, -- title, content, summary等
    diff_type ENUM('add', 'delete', 'modify') NOT NULL,
    old_value TEXT,
    new_value TEXT,
    line_number INT, -- 文本行号
    char_position INT, -- 字符位置
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_content_version (content_id, from_version, to_version),
    INDEX idx_field_name (field_name),
    FOREIGN KEY (content_id) REFERENCES contents(id) ON DELETE CASCADE
);
```

### API接口规范

#### 版本管理接口
- **GET /api/v1/contents/{id}/versions**
  - 查询参数:
    - page, page_size: 分页参数
    - include_content: 是否包含完整内容 (默认false)
    - from_date, to_date: 时间范围过滤
  - 响应: 200 OK + 版本列表
  - 权限: 内容可见性检查

- **GET /api/v1/contents/{id}/versions/{version}**
  - 获取指定版本的完整内容
  - 响应: 200 OK + 版本详情
  - 权限: 内容作者或管理员

- **POST /api/v1/contents/{id}/revert**
  - 请求体: target_version, revert_reason
  - 回退到指定版本
  - 响应: 200 OK + 新版本信息
  - 权限: 内容作者或管理员

#### 版本对比接口
- **GET /api/v1/contents/{id}/compare**
  - 查询参数:
    - from_version: 源版本号
    - to_version: 目标版本号 (默认当前版本)
    - diff_type: 对比类型 (unified, side_by_side, summary)
  - 响应: 200 OK + 对比结果
  - 权限: 内容作者或管理员

- **GET /api/v1/contents/{id}/diff/{from_version}/{to_version}**
  - 获取两个版本间的详细差异
  - 响应: 200 OK + 结构化差异数据

### 版本管理机制

#### 自动版本创建
```python
def create_version_on_update(content_id, old_data, new_data, user_id, change_type='update'):
    """内容更新时自动创建版本"""
    # 1. 获取下一个版本号
    next_version = get_next_version_number(content_id)

    # 2. 保存旧版本数据
    version_data = {
        'content_id': content_id,
        'version_number': next_version,
        'title': old_data['title'],
        'content': old_data['content'],
        'summary': old_data['summary'],
        'content_type': old_data['content_type'],
        'metadata': old_data.get('metadata', {}),
        'change_type': change_type,
        'change_summary': generate_change_summary(old_data, new_data),
        'changed_by': user_id
    }

    version_id = ContentVersionRepository.create(version_data)

    # 3. 生成差异数据
    generate_content_diffs(content_id, next_version - 1, next_version, old_data, new_data)

    return version_id
```

#### 变更摘要生成
```python
def generate_change_summary(old_data, new_data):
    """生成变更摘要"""
    changes = []

    if old_data['title'] != new_data['title']:
        changes.append('修改标题')

    if old_data['content'] != new_data['content']:
        old_len = len(old_data['content'])
        new_len = len(new_data['content'])
        if new_len > old_len:
            changes.append(f'新增{new_len - old_len}个字符')
        elif new_len < old_len:
            changes.append(f'删除{old_len - new_len}个字符')
        else:
            changes.append('修改内容')

    if old_data['summary'] != new_data['summary']:
        changes.append('更新摘要')

    return ', '.join(changes) if changes else '无变更'
```

### 版本对比算法

#### 文本差异算法
```python
import difflib

def generate_text_diff(old_text, new_text, diff_type='unified'):
    """生成文本差异"""
    old_lines = old_text.splitlines(keepends=True)
    new_lines = new_text.splitlines(keepends=True)

    if diff_type == 'unified':
        # 统一差异格式
        diff = list(difflib.unified_diff(
            old_lines, new_lines,
            fromfile='旧版本',
            tofile='新版本',
            lineterm=''
        ))
        return '\n'.join(diff)

    elif diff_type == 'side_by_side':
        # 并排对比格式
        differ = difflib.HtmlDiff()
        return differ.make_table(old_lines, new_lines)

    elif diff_type == 'summary':
        # 简要对比
        return generate_diff_summary(old_lines, new_lines)
```

#### 结构化差异数据
```python
def generate_content_diffs(content_id, from_version, to_version, old_data, new_data):
    """生成结构化差异数据"""
    diffs = []

    # 比较各个字段
    for field in ['title', 'content', 'summary']:
        old_value = old_data.get(field, '')
        new_value = new_data.get(field, '')

        if old_value != new_value:
            # 计算详细差异
            field_diffs = calculate_field_diff(old_value, new_value)
            for diff in field_diffs:
                diffs.append({
                    'content_id': content_id,
                    'from_version': from_version,
                    'to_version': to_version,
                    'field_name': field,
                    'diff_type': diff['type'],
                    'old_value': diff['old_value'],
                    'new_value': diff['new_value'],
                    'line_number': diff.get('line_number'),
                    'char_position': diff.get('char_position')
                })

    # 批量插入差异数据
    ContentDiffRepository.bulk_create(diffs)
```

### 版本回退功能

#### 版本回退实现
```python
def revert_to_version(content_id, target_version, user_id, reason=None):
    """回退到指定版本"""
    # 1. 获取目标版本数据
    target_version_data = ContentVersionRepository.get_by_version(content_id, target_version)
    if not target_version_data:
        raise ValueError(f"版本 {target_version} 不存在")

    # 2. 获取当前内容数据
    current_content = ContentRepository.get_by_id(content_id)

    # 3. 创建当前版本快照
    create_version_on_update(
        content_id,
        current_content,
        target_version_data,
        user_id,
        change_type='revert'
    )

    # 4. 更新内容为目标版本
    ContentRepository.update(content_id, {
        'title': target_version_data['title'],
        'content': target_version_data['content'],
        'summary': target_version_data['summary'],
        'updated_at': datetime.now()
    })

    # 5. 记录回退操作
    log_version_operation(content_id, 'revert', user_id, {
        'target_version': target_version,
        'reason': reason
    })

    return True
```

### 版本清理机制

#### 定期清理任务
```python
@celery.task
def cleanup_old_versions():
    """清理过旧版本"""
    # 保留策略:
    # 1. 最近 30 天的所有版本
    # 2. 每月第一个版本 (最近 12 个月)
    # 3. 每年第一个版本 (永久保存)

    cutoff_date = datetime.now() - timedelta(days=30)

    # 查找可清理的版本
    old_versions = ContentVersionRepository.get_cleanable_versions(cutoff_date)

    for version in old_versions:
        # 检查是否为重要版本
        if not is_important_version(version):
            ContentVersionRepository.delete(version.id)
            ContentDiffRepository.delete_by_version(version.content_id, version.version_number)

    logger.info(f"清理了 {len(old_versions)} 个过旧版本")
```

## Dependencies

- [ ] Task 001: 后端基础架构
- [ ] Task 013: 内容核心CRUD系统
- [ ] 文本对比算法库 (difflib 或 python-diff)
- [ ] Celery定时任务 (版本清理)

## Effort Estimate

- Size: L
- Hours: 26小时
- Parallel: true

## Definition of Done

- [ ] 所有版本管理API接口实现完成
- [ ] 版本创建和存储机制正常
- [ ] 版本对比功能精确
- [ ] 版本回退功能正常
- [ ] 版本清理机制有效
- [ ] 性能满足要求 (对比<500ms)
- [ ] 单元测试覆盖率达到90%
- [ ] 集成测试通过
- [ ] API文档更新完成

## Implementation Notes

### Service层设计
```python
class ContentVersionService:
    def create_version(self, content_id, version_data, user_id):
        """创建新版本"""
        pass

    def get_version_history(self, content_id, page=1, page_size=20):
        """获取版本历史"""
        pass

    def compare_versions(self, content_id, from_version, to_version, diff_type='unified'):
        """版本对比"""
        pass

    def revert_to_version(self, content_id, target_version, user_id, reason=None):
        """版本回退"""
        pass

    def cleanup_old_versions(self, retention_policy):
        """清理旧版本"""
        pass
```

### 缓存策略
- `content:versions:{id}`: 版本列表缓存 (TTL: 30分钟)
- `content:version:{id}:{version}`: 具体版本缓存 (TTL: 2小时)
- `content:diff:{hash}`: 对比结果缓存 (TTL: 1小时)

### 性能优化
- 大内容分块存储
- 差异数据压缩存储
- 版本列表分页优化
- 对比结果缓存

### 错误处理
- 404: 版本不存在
- 400: 版本参数无效
- 422: 回退目标版本无效
- 413: 版本数据过大

### 安全考虑
- 版本访问权限控制
- 敏感数据版本加密存储
- 版本操作审计日志
- 恶意回退防护