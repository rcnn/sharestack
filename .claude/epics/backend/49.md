---
name: 内容推荐系统基础
status: backlog
created: 2025-09-15T02:51:00Z
github: https://github.com/rcnn/sharestack/issues/49
depends_on: [34, 35]
parallel: true
conflicts_with: []
---

# Task: 内容推荐系统基础

## Description

实现基础的内容推荐系统，包括推荐算法实现、用户行为分析、推荐内容API、推荐效果统计等功能。为用户提供个性化的内容发现体验。

## Acceptance Criteria

- [ ] 实现推荐算法基础实现
- [ ] 实现推荐内容API
- [ ] 实现用户偏好分析
- [ ] 实现推荐效果统计
- [ ] 实现实时推荐更新
- [ ] 实现推荐结果缓存
- [ ] 实现A/B测试支持
- [ ] 编写完整的测试用例

## Technical Details

### 推荐系统数据模型

#### User_Preferences用户偏好表
```sql
CREATE TABLE user_preferences (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    category_preferences JSON, -- 分类偏好权重
    tag_preferences JSON, -- 标签偏好权重
    author_preferences JSON, -- 作者偏好权重
    content_type_preferences JSON, -- 内容类型偏好
    interaction_preferences JSON, -- 交互行为偏好
    last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE KEY unique_user_preference (user_id),
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
```

#### User_Interactions用户交互表
```sql
CREATE TABLE user_interactions (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    content_id BIGINT NOT NULL,
    interaction_type ENUM('view', 'like', 'comment', 'share', 'bookmark', 'purchase') NOT NULL,
    interaction_value DECIMAL(3,2) DEFAULT 1.0, -- 交互权重
    duration INT DEFAULT 0, -- 浏览时长(秒)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_user_content (user_id, content_id),
    INDEX idx_interaction_type (interaction_type),
    INDEX idx_created_at (created_at),
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (content_id) REFERENCES contents(id) ON DELETE CASCADE
);
```

#### Recommendation_Results推荐结果表
```sql
CREATE TABLE recommendation_results (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    content_id BIGINT NOT NULL,
    recommendation_type ENUM('collaborative', 'content_based', 'popularity', 'hybrid') NOT NULL,
    score DECIMAL(5,4) NOT NULL, -- 推荐分数
    algorithm_version VARCHAR(50) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP NOT NULL,
    INDEX idx_user_score (user_id, score DESC),
    INDEX idx_expires_at (expires_at),
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (content_id) REFERENCES contents(id) ON DELETE CASCADE
);
```

### 推荐算法实现

#### 协同过滤算法
```python
import numpy as np
from scipy.sparse import csr_matrix
from scipy.spatial.distance import cosine
from sklearn.metrics.pairwise import cosine_similarity

class CollaborativeFilteringRecommender:
    def __init__(self):
        self.user_item_matrix = None
        self.user_similarity_matrix = None
        self.item_similarity_matrix = None
        
    def build_user_item_matrix(self):
        """构建用户-物品矩阵"""
        # 获取用户交互数据
        interactions = UserInteractionRepository.get_all_interactions()
        
        # 创建用户和内容映射
        users = list(set([i.user_id for i in interactions]))
        contents = list(set([i.content_id for i in interactions]))
        
        user_to_idx = {user: idx for idx, user in enumerate(users)}
        content_to_idx = {content: idx for idx, content in enumerate(contents)}
        
        # 创建稀疏矩阵
        rows, cols, data = [], [], []
        
        for interaction in interactions:
            user_idx = user_to_idx[interaction.user_id]
            content_idx = content_to_idx[interaction.content_id]
            
            # 计算交互分数
            score = self._calculate_interaction_score(interaction)
            
            rows.append(user_idx)
            cols.append(content_idx)
            data.append(score)
        
        self.user_item_matrix = csr_matrix(
            (data, (rows, cols)), 
            shape=(len(users), len(contents))
        )
        
        self.user_to_idx = user_to_idx
        self.content_to_idx = content_to_idx
        self.idx_to_user = {idx: user for user, idx in user_to_idx.items()}
        self.idx_to_content = {idx: content for content, idx in content_to_idx.items()}
        
        return self.user_item_matrix
    
    def _calculate_interaction_score(self, interaction):
        """计算交互分数"""
        base_scores = {
            'view': 1.0,
            'like': 3.0,
            'comment': 4.0,
            'share': 5.0,
            'bookmark': 6.0,
            'purchase': 10.0
        }
        
        score = base_scores.get(interaction.interaction_type, 1.0)
        
        # 根据浏览时长调整分数
        if interaction.interaction_type == 'view' and interaction.duration:
            # 浏览时间越长，分数越高
            duration_bonus = min(interaction.duration / 60, 5)  # 最多5分
            score += duration_bonus
        
        return score
    
    def calculate_user_similarity(self):
        """计算用户相似度"""
        if self.user_item_matrix is None:
            self.build_user_item_matrix()
        
        # 使用余弦相似度
        self.user_similarity_matrix = cosine_similarity(self.user_item_matrix)
        
        return self.user_similarity_matrix
    
    def recommend_by_user_similarity(self, user_id, top_k=20):
        """基于用户相似度的推荐"""
        if user_id not in self.user_to_idx:
            return []
        
        user_idx = self.user_to_idx[user_id]
        
        # 找到相似用户
        user_similarities = self.user_similarity_matrix[user_idx]
        similar_users = np.argsort(user_similarities)[::-1][1:11]  # 前10个相似用户
        
        # 获取当前用户已交互的内容
        user_interactions = set(
            UserInteractionRepository.get_user_interacted_contents(user_id)
        )
        
        # 收集相似用户喜欢的内容
        recommendations = {}
        
        for similar_user_idx in similar_users:
            similar_user_id = self.idx_to_user[similar_user_idx]
            similarity = user_similarities[similar_user_idx]
            
            # 获取相似用户的高分内容
            similar_user_contents = UserInteractionRepository.get_user_high_score_contents(
                similar_user_id, min_score=3.0
            )
            
            for content_id, score in similar_user_contents:
                if content_id not in user_interactions:
                    if content_id not in recommendations:
                        recommendations[content_id] = 0
                    recommendations[content_id] += similarity * score
        
        # 排序并返回前k个推荐
        sorted_recommendations = sorted(
            recommendations.items(), 
            key=lambda x: x[1], 
            reverse=True
        )[:top_k]
        
        return [(content_id, score) for content_id, score in sorted_recommendations]
```

#### 内容基础推荐算法
```python
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import linear_kernel

class ContentBasedRecommender:
    def __init__(self):
        self.tfidf_vectorizer = TfidfVectorizer(
            max_features=5000,
            stop_words='english',
            ngram_range=(1, 2)
        )
        self.content_vectors = None
        self.content_similarity_matrix = None
        
    def build_content_vectors(self):
        """构建内容向量"""
        # 获取所有内容
        contents = ContentRepository.get_all_published()
        
        # 构建内容特征文本
        content_features = []
        self.content_ids = []
        
        for content in contents:
            # 合并文本特征
            features = [
                content.title or '',
                content.summary or '',
                ' '.join([tag.name for tag in content.tags.all()]) if hasattr(content, 'tags') else '',
                ' '.join([cat.name for cat in content.categories.all()]) if hasattr(content, 'categories') else '',
                content.author.username or ''
            ]
            
            content_features.append(' '.join(features))
            self.content_ids.append(content.id)
        
        # 构建 TF-IDF 向量
        self.content_vectors = self.tfidf_vectorizer.fit_transform(content_features)
        self.content_id_to_idx = {content_id: idx for idx, content_id in enumerate(self.content_ids)}
        
        return self.content_vectors
    
    def calculate_content_similarity(self):
        """计算内容相似度"""
        if self.content_vectors is None:
            self.build_content_vectors()
        
        # 计算余弦相似度
        self.content_similarity_matrix = linear_kernel(self.content_vectors, self.content_vectors)
        
        return self.content_similarity_matrix
    
    def recommend_by_content_similarity(self, user_id, top_k=20):
        """基于内容相似度的推荐"""
        # 获取用户历史交互高分内容
        user_high_score_contents = UserInteractionRepository.get_user_high_score_contents(
            user_id, min_score=3.0, limit=20
        )
        
        if not user_high_score_contents:
            return []
        
        # 获取用户已交互内容
        user_interactions = set(
            UserInteractionRepository.get_user_interacted_contents(user_id)
        )
        
        # 收集相似内容推荐
        recommendations = {}
        
        for content_id, user_score in user_high_score_contents:
            if content_id not in self.content_id_to_idx:
                continue
                
            content_idx = self.content_id_to_idx[content_id]
            
            # 获取相似内容
            content_similarities = self.content_similarity_matrix[content_idx]
            similar_content_indices = np.argsort(content_similarities)[::-1][1:21]  # 前20个相似内容
            
            for similar_idx in similar_content_indices:
                similar_content_id = self.content_ids[similar_idx]
                similarity = content_similarities[similar_idx]
                
                if similar_content_id not in user_interactions:
                    if similar_content_id not in recommendations:
                        recommendations[similar_content_id] = 0
                    recommendations[similar_content_id] += user_score * similarity
        
        # 排序并返回
        sorted_recommendations = sorted(
            recommendations.items(),
            key=lambda x: x[1],
            reverse=True
        )[:top_k]
        
        return [(content_id, score) for content_id, score in sorted_recommendations]
```

#### 混合推荐算法
```python
class HybridRecommender:
    def __init__(self):
        self.cf_recommender = CollaborativeFilteringRecommender()
        self.cb_recommender = ContentBasedRecommender()
        self.popularity_recommender = PopularityRecommender()
        
    def get_hybrid_recommendations(self, user_id, top_k=20):
        """混合推荐算法"""
        # 获取不同算法的推荐结果
        cf_recommendations = self.cf_recommender.recommend_by_user_similarity(user_id, top_k * 2)
        cb_recommendations = self.cb_recommender.recommend_by_content_similarity(user_id, top_k * 2)
        popularity_recommendations = self.popularity_recommender.get_popular_contents(top_k)
        
        # 设置算法权重
        weights = {
            'collaborative': 0.4,
            'content_based': 0.4,
            'popularity': 0.2
        }
        
        # 合并推荐结果
        combined_recommendations = {}
        
        # 协同过滤结果
        for content_id, score in cf_recommendations:
            if content_id not in combined_recommendations:
                combined_recommendations[content_id] = {'score': 0, 'sources': []}
            combined_recommendations[content_id]['score'] += score * weights['collaborative']
            combined_recommendations[content_id]['sources'].append('collaborative')
        
        # 内容基础结果
        for content_id, score in cb_recommendations:
            if content_id not in combined_recommendations:
                combined_recommendations[content_id] = {'score': 0, 'sources': []}
            combined_recommendations[content_id]['score'] += score * weights['content_based']
            combined_recommendations[content_id]['sources'].append('content_based')
        
        # 热门内容结果
        for content_id, score in popularity_recommendations:
            if content_id not in combined_recommendations:
                combined_recommendations[content_id] = {'score': 0, 'sources': []}
            combined_recommendations[content_id]['score'] += score * weights['popularity']
            combined_recommendations[content_id]['sources'].append('popularity')
        
        # 排序并返回
        sorted_recommendations = sorted(
            combined_recommendations.items(),
            key=lambda x: x[1]['score'],
            reverse=True
        )[:top_k]
        
        return [
            {
                'content_id': content_id,
                'score': data['score'],
                'sources': data['sources']
            }
            for content_id, data in sorted_recommendations
        ]
```

### 推荐服务API

#### 推荐API实现
```python
class RecommendationService:
    def __init__(self):
        self.hybrid_recommender = HybridRecommender()
        self.recommendation_cache = RecommendationCache()
        
    def get_recommendations(self, user_id, recommendation_type='hybrid', limit=20, **kwargs):
        """获取推荐内容"""
        # 检查缓存
        cache_key = f"rec:{user_id}:{recommendation_type}:{limit}"
        cached_result = self.recommendation_cache.get(cache_key)
        
        if cached_result:
            return cached_result
        
        # 生成推荐
        if recommendation_type == 'hybrid':
            recommendations = self.hybrid_recommender.get_hybrid_recommendations(user_id, limit)
        elif recommendation_type == 'collaborative':
            cf_recommender = CollaborativeFilteringRecommender()
            recommendations = cf_recommender.recommend_by_user_similarity(user_id, limit)
        elif recommendation_type == 'content_based':
            cb_recommender = ContentBasedRecommender()
            recommendations = cb_recommender.recommend_by_content_similarity(user_id, limit)
        elif recommendation_type == 'popularity':
            popularity_recommender = PopularityRecommender()
            recommendations = popularity_recommender.get_popular_contents(limit)
        else:
            recommendations = []
        
        # 补充内容详情
        enriched_recommendations = self._enrich_recommendations(recommendations, user_id)
        
        # 缓存结果
        self.recommendation_cache.set(cache_key, enriched_recommendations, ttl=3600)
        
        # 记录推荐结果
        self._record_recommendation_results(user_id, enriched_recommendations, recommendation_type)
        
        return enriched_recommendations
    
    def _enrich_recommendations(self, recommendations, user_id):
        """丰富推荐结果"""
        if not recommendations:
            return []
        
        # 获取内容ID列表
        if isinstance(recommendations[0], dict):
            content_ids = [rec['content_id'] for rec in recommendations]
        else:
            content_ids = [rec[0] for rec in recommendations]
        
        # 批量获取内容详情
        contents = ContentRepository.get_by_ids(content_ids)
        content_dict = {content.id: content for content in contents}
        
        # 构建结果
        enriched_results = []
        
        for i, rec in enumerate(recommendations):
            if isinstance(rec, dict):
                content_id = rec['content_id']
                score = rec['score']
                sources = rec.get('sources', [])
            else:
                content_id = rec[0]
                score = rec[1]
                sources = []
            
            content = content_dict.get(content_id)
            if not content:
                continue
            
            enriched_results.append({
                'content_id': content_id,
                'title': content.title,
                'summary': content.summary,
                'author': {
                    'id': content.author.id,
                    'username': content.author.username,
                    'nickname': getattr(content.author, 'nickname', content.author.username)
                },
                'content_type': content.content_type,
                'is_paid': content.is_paid,
                'price': float(content.price) if content.price else 0.0,
                'created_at': content.created_at.isoformat(),
                'recommendation_score': score,
                'recommendation_sources': sources,
                'rank': i + 1
            })
        
        return enriched_results
    
    def _record_recommendation_results(self, user_id, recommendations, rec_type):
        """记录推荐结果"""
        # 异步记录推荐结果
        record_recommendation_task.delay(user_id, recommendations, rec_type)
    
    def update_user_preferences(self, user_id):
        """更新用户偏好"""
        preferences_analyzer = UserPreferencesAnalyzer()
        preferences = preferences_analyzer.analyze_user_preferences(user_id)
        
        # 保存用户偏好
        UserPreferencesRepository.update_or_create(user_id, preferences)
        
        # 清理相关缓存
        self.recommendation_cache.clear_user_cache(user_id)
        
        return preferences
    
    def get_recommendation_explanation(self, user_id, content_id):
        """获取推荐解释"""
        # 分析为什么推荐这个内容
        explanation = {
            'reasons': [],
            'similar_contents': [],
            'similar_users': []
        }
        
        # 获取用户偏好
        preferences = UserPreferencesRepository.get_by_user_id(user_id)
        content = ContentRepository.get_by_id(content_id)
        
        if not content or not preferences:
            return explanation
        
        # 分析推荐原因
        if hasattr(content, 'categories'):
            for category in content.categories.all():
                if category.name in preferences.category_preferences:
                    weight = preferences.category_preferences[category.name]
                    if weight > 0.5:
                        explanation['reasons'].append(f"您对'{category.name}'分类的内容感兴趣")
        
        if hasattr(content, 'tags'):
            for tag in content.tags.all():
                if tag.name in preferences.tag_preferences:
                    weight = preferences.tag_preferences[tag.name]
                    if weight > 0.5:
                        explanation['reasons'].append(f"您经常阅读有'{tag.name}'标签的内容")
        
        return explanation
```

### 推荐效果统计

#### 推荐效果分析
```python
class RecommendationAnalytics:
    def track_recommendation_click(self, user_id, content_id, recommendation_id, position):
        """跟踪推荐点击"""
        click_data = {
            'user_id': user_id,
            'content_id': content_id,
            'recommendation_id': recommendation_id,
            'position': position,
            'clicked_at': datetime.now()
        }
        
        # 异步记录点击数据
        record_recommendation_click.delay(click_data)
    
    def calculate_recommendation_metrics(self, date_range=None):
        """计算推荐指标"""
        if not date_range:
            end_date = datetime.now()
            start_date = end_date - timedelta(days=7)
        else:
            start_date = date_range['start']
            end_date = date_range['end']
        
        metrics = {
            'ctr': 0,  # 点击率
            'coverage': 0,  # 覆盖率
            'diversity': 0,  # 多样性
            'novelty': 0,  # 新颖性
            'precision': 0,  # 准确率
            'recall': 0  # 召回率
        }
        
        # 计算CTR
        total_recommendations = RecommendationResultRepository.count_by_date_range(start_date, end_date)
        total_clicks = RecommendationClickRepository.count_by_date_range(start_date, end_date)
        
        if total_recommendations > 0:
            metrics['ctr'] = total_clicks / total_recommendations
        
        # 计算覆盖率
        total_contents = ContentRepository.count_published()
        recommended_contents = RecommendationResultRepository.count_unique_contents(start_date, end_date)
        
        if total_contents > 0:
            metrics['coverage'] = recommended_contents / total_contents
        
        # 计算多样性
        metrics['diversity'] = self._calculate_diversity(start_date, end_date)
        
        # 计算新颖性
        metrics['novelty'] = self._calculate_novelty(start_date, end_date)
        
        return metrics
    
    def _calculate_diversity(self, start_date, end_date):
        """计算推荐多样性"""
        # 获取推荐结果
        recommendations = RecommendationResultRepository.get_by_date_range(start_date, end_date)
        
        if not recommendations:
            return 0
        
        # 计算分类多样性
        category_counts = {}
        total_recommendations = len(recommendations)
        
        for rec in recommendations:
            content = ContentRepository.get_by_id(rec.content_id)
            if content and hasattr(content, 'categories'):
                for category in content.categories.all():
                    category_counts[category.name] = category_counts.get(category.name, 0) + 1
        
        # 计算熵
        if not category_counts:
            return 0
        
        entropy = 0
        for count in category_counts.values():
            prob = count / total_recommendations
            if prob > 0:
                entropy -= prob * np.log2(prob)
        
        return entropy
    
    def _calculate_novelty(self, start_date, end_date):
        """计算推荐新颖性"""
        # 获取推荐的内容
        recommendations = RecommendationResultRepository.get_by_date_range(start_date, end_date)
        
        if not recommendations:
            return 0
        
        total_novelty = 0
        count = 0
        
        for rec in recommendations:
            content = ContentRepository.get_by_id(rec.content_id)
            if content:
                # 计算内容的新颖性（基于发布时间和热度）
                days_since_published = (datetime.now() - content.created_at).days
                popularity_score = getattr(content, 'view_count', 0) + getattr(content, 'like_count', 0) * 2
                
                # 新颖性 = 时间新靶度 / (1 + 热度分数)
                novelty = (1 / (1 + days_since_published)) / (1 + np.log(1 + popularity_score))
                total_novelty += novelty
                count += 1
        
        return total_novelty / count if count > 0 else 0
```

## Dependencies

- [ ] Task 013: 内容核心CRUD系统
- [ ] Task 014: 内容列表和搜索系统
- [ ] 用户管理模块 (用户行为数据)
- [ ] scikit-learn机器学习库
- [ ] NumPy和SciPy科学计算库
- [ ] Celery异步任务处理

## Effort Estimate

- Size: XL
- Hours: 35小时
- Parallel: true

## Definition of Done

- [ ] 所有推荐算法实现完成
- [ ] 推荐API接口正常工作
- [ ] 用户偏好分析准确
- [ ] 推荐效果统计完整
- [ ] 推荐结果质量满足要求
- [ ] 系统性能满足要求 (API<200ms)
- [ ] 单元测试覆盖率达到90%
- [ ] A/B测试支持完整
- [ ] API文档更新完成

## Implementation Notes

### Service层设计
```python
class RecommendationService:
    def get_recommendations(self, user_id, rec_type, limit):
        """获取推荐内容"""
        pass

    def update_user_interaction(self, user_id, content_id, interaction_type):
        """更新用户交互"""
        pass

    def analyze_recommendation_performance(self, date_range):
        """分析推荐性能"""
        pass

    def retrain_models(self):
        """重新训练模型"""
        pass
```

### 缓存策略
- `rec:{user_id}:{type}`: 用户推荐结果 (TTL: 1小时)
- `user:preferences:{user_id}`: 用户偏好 (TTL: 24小时)
- `rec:popular`: 热门内容推荐 (TTL: 30分钟)

### 性能优化
- 推荐结果缓存
- 实时更新用户偏好
- 分布式模型计算
- 特征向量预计算

### 错误处理
- 404: 用户不存在
- 422: 推荐参数无效
- 500: 推荐算法失败
- 503: 推荐服务不可用

### 算法优化
- 在线学习算法
- 冷启动问题处理
- 数据稀疏性处理
- 实时推荐更新