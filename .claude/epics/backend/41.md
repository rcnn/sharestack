---
name: 文件上传系统
status: backlog
created: 2025-09-15T02:51:00Z
github: https://github.com/rcnn/sharestack/issues/41
depends_on: [001]
parallel: true
conflicts_with: []
---

# Task: 文件上传系统

## Description

实现完整的文件上传系统，支持单文件、批量上传、断点续传、文件类型验证、上传进度跟踪等功能。为内容创作提供稳定高效的文件上传支持。

## Acceptance Criteria

- [ ] 完成文件上传API (/api/v1/media/upload)
- [ ] 完成批量上传API (/api/v1/media/batch-upload)
- [ ] 实现文件类型验证
- [ ] 实现上传进度跟踪
- [ ] 实现断点续传功能
- [ ] 实现文件安全检查
- [ ] 实现上传限制管理
- [ ] 编写完整的测试用例

## Technical Details

### 文件数据模型设计

#### Media_Files媒体文件表
```sql
CREATE TABLE media_files (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    filename VARCHAR(255) NOT NULL,
    original_filename VARCHAR(255) NOT NULL,
    file_path VARCHAR(500) NOT NULL,
    file_size BIGINT NOT NULL,
    file_type ENUM('image', 'video', 'audio', 'document', 'other') NOT NULL,
    mime_type VARCHAR(100) NOT NULL,
    file_extension VARCHAR(10) NOT NULL,
    file_hash VARCHAR(64) NOT NULL, -- SHA-256文件哈希
    upload_status ENUM('pending', 'uploading', 'completed', 'failed', 'processing') DEFAULT 'pending',
    upload_progress DECIMAL(5,2) DEFAULT 0.00, -- 上传进度
    uploaded_by BIGINT NOT NULL,
    content_id BIGINT NULL, -- 关联的内容ID
    storage_provider ENUM('local', 's3', 'oss', 'qiniu') DEFAULT 'local',
    storage_path VARCHAR(500), -- 云存储路径
    cdn_url VARCHAR(500), -- CDN访问地址
    metadata JSON, -- 文件元数据 (宽高、时长等)
    is_public BOOLEAN DEFAULT FALSE,
    expires_at TIMESTAMP NULL, -- 文件过期时间
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL,
    INDEX idx_file_hash (file_hash),
    INDEX idx_uploaded_by (uploaded_by),
    INDEX idx_content_id (content_id),
    INDEX idx_file_type (file_type),
    INDEX idx_upload_status (upload_status),
    INDEX idx_created_at (created_at),
    FOREIGN KEY (uploaded_by) REFERENCES users(id),
    FOREIGN KEY (content_id) REFERENCES contents(id)
);
```

#### Upload_Sessions上传会话表
```sql
CREATE TABLE upload_sessions (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    session_id VARCHAR(64) NOT NULL UNIQUE,
    filename VARCHAR(255) NOT NULL,
    file_size BIGINT NOT NULL,
    chunk_size INT DEFAULT 1048576, -- 1MB
    total_chunks INT NOT NULL,
    uploaded_chunks INT DEFAULT 0,
    upload_status ENUM('active', 'completed', 'failed', 'expired') DEFAULT 'active',
    user_id BIGINT NOT NULL,
    temp_file_path VARCHAR(500),
    expires_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_session_id (session_id),
    INDEX idx_user_id (user_id),
    INDEX idx_expires_at (expires_at),
    FOREIGN KEY (user_id) REFERENCES users(id)
);
```

### API接口规范

#### 文件上传接口
- **POST /api/v1/media/upload**
  - 请求格式: multipart/form-data
  - 请求参数:
    - file: 文件数据 (必填)
    - content_id: 关联内容ID (可选)
    - is_public: 是否公开 (默认false)
    - description: 文件描述 (可选)
  - 响应: 201 Created + 文件信息
  - 权限: 认证用户

- **POST /api/v1/media/batch-upload**
  - 请求格式: multipart/form-data
  - 支持多个文件同时上传
  - 响应: 201 Created + 批量上传结果
  - 权限: 认证用户

#### 断点续传接口
- **POST /api/v1/media/upload/init**
  - 请求体: filename, file_size, chunk_size
  - 初始化上传会话
  - 响应: 201 Created + 会话信息

- **POST /api/v1/media/upload/chunk**
  - 请求参数:
    - session_id: 上传会话 ID
    - chunk_index: 分块索引
    - chunk_data: 分块数据
  - 上传文件分块
  - 响应: 200 OK + 进度信息

- **POST /api/v1/media/upload/complete**
  - 请求体: session_id
  - 完成分块上传并合并文件
  - 响应: 201 Created + 最终文件信息

#### 上传管理接口
- **GET /api/v1/media/upload/progress/{session_id}**
  - 获取上传进度
  - 响应: 200 OK + 进度信息

- **DELETE /api/v1/media/upload/cancel/{session_id}**
  - 取消上传会话
  - 响应: 204 No Content

### 文件上传实现

#### 单文件上传服务
```python
class FileUploadService:
    def upload_file(self, file_data, user_id, content_id=None, is_public=False):
        """单文件上传"""
        # 1. 验证文件
        validation_result = self.validate_file(file_data, user_id)
        if not validation_result['valid']:
            raise ValidationError(validation_result['error'])

        # 2. 生成文件哈希
        file_hash = self.calculate_file_hash(file_data)

        # 3. 检查文件是否已存在
        existing_file = MediaFileRepository.get_by_hash(file_hash)
        if existing_file:
            return self.handle_duplicate_file(existing_file, user_id, content_id)

        # 4. 生成文件名和路径
        filename = self.generate_unique_filename(file_data.filename)
        file_path = self.generate_file_path(filename, user_id)

        # 5. 保存文件
        storage_result = self.save_file(file_data, file_path)
        if not storage_result['success']:
            raise StorageError(storage_result['error'])

        # 6. 创建数据库记录
        file_record = self.create_file_record({
            'filename': filename,
            'original_filename': file_data.filename,
            'file_path': file_path,
            'file_size': file_data.size,
            'file_type': self.detect_file_type(file_data),
            'mime_type': file_data.content_type,
            'file_extension': self.get_file_extension(file_data.filename),
            'file_hash': file_hash,
            'uploaded_by': user_id,
            'content_id': content_id,
            'is_public': is_public,
            'upload_status': 'completed'
        })

        # 7. 异步处理文件元数据
        self.process_file_metadata.delay(file_record.id)

        return file_record
```

#### 断点续传服务
```python
class ChunkedUploadService:
    def init_upload_session(self, filename, file_size, user_id, chunk_size=1024*1024):
        """初始化上传会话"""
        # 1. 验证参数
        if file_size > settings.MAX_FILE_SIZE:
            raise ValidationError(f"文件大小超出限制: {settings.MAX_FILE_SIZE}")

        # 2. 检查用户上传限制
        self.check_user_upload_quota(user_id, file_size)

        # 3. 生成会话 ID
        session_id = str(uuid.uuid4())
        total_chunks = math.ceil(file_size / chunk_size)

        # 4. 创建上传会话
        session = UploadSessionRepository.create({
            'session_id': session_id,
            'filename': filename,
            'file_size': file_size,
            'chunk_size': chunk_size,
            'total_chunks': total_chunks,
            'user_id': user_id,
            'expires_at': datetime.now() + timedelta(hours=24)
        })

        return {
            'session_id': session_id,
            'total_chunks': total_chunks,
            'chunk_size': chunk_size,
            'expires_at': session.expires_at
        }

    def upload_chunk(self, session_id, chunk_index, chunk_data):
        """上传文件分块"""
        # 1. 获取上传会话
        session = UploadSessionRepository.get_by_session_id(session_id)
        if not session or session.upload_status != 'active':
            raise SessionError("上传会话无效或已过期")

        # 2. 验证分块索引
        if chunk_index >= session.total_chunks:
            raise ValidationError("分块索引超出范围")

        # 3. 保存分块数据
        chunk_path = self.get_chunk_path(session_id, chunk_index)
        with open(chunk_path, 'wb') as f:
            f.write(chunk_data)

        # 4. 更新上传进度
        session.uploaded_chunks += 1
        session.upload_progress = (session.uploaded_chunks / session.total_chunks) * 100
        UploadSessionRepository.update(session)

        return {
            'uploaded_chunks': session.uploaded_chunks,
            'total_chunks': session.total_chunks,
            'progress': session.upload_progress
        }

    def complete_upload(self, session_id):
        """完成分块上传"""
        # 1. 获取会话信息
        session = UploadSessionRepository.get_by_session_id(session_id)
        if not session:
            raise SessionError("上传会话不存在")

        # 2. 检查所有分块是否上传完成
        if session.uploaded_chunks != session.total_chunks:
            raise ValidationError("上传未完成，请上传所有分块")

        # 3. 合并文件分块
        final_file_path = self.merge_chunks(session)

        # 4. 验证文件完整性
        if not self.verify_file_integrity(final_file_path, session.file_size):
            raise IntegrityError("文件完整性验证失败")

        # 5. 创建文件记录
        file_record = self.create_final_file_record(session, final_file_path)

        # 6. 清理上传会话
        self.cleanup_upload_session(session)

        return file_record
```

### 文件验证和安全检查

#### 文件类型验证
```python
class FileValidationService:
    ALLOWED_EXTENSIONS = {
        'image': ['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg'],
        'video': ['mp4', 'avi', 'mov', 'wmv', 'flv', 'webm'],
        'audio': ['mp3', 'wav', 'flac', 'aac', 'm4a'],
        'document': ['pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'txt']
    }

    MAX_FILE_SIZES = {
        'image': 10 * 1024 * 1024,  # 10MB
        'video': 500 * 1024 * 1024,  # 500MB
        'audio': 50 * 1024 * 1024,   # 50MB
        'document': 20 * 1024 * 1024  # 20MB
    }

    def validate_file(self, file_data, user_id):
        """文件验证"""
        # 1. 文件大小检查
        file_type = self.detect_file_type(file_data)
        max_size = self.MAX_FILE_SIZES.get(file_type, 1024*1024)
        if file_data.size > max_size:
            return {'valid': False, 'error': f'{file_type}文件大小不能超过{max_size//1024//1024}MB'}

        # 2. 文件类型检查
        file_ext = self.get_file_extension(file_data.filename).lower()
        allowed_exts = self.ALLOWED_EXTENSIONS.get(file_type, [])
        if file_ext not in allowed_exts:
            return {'valid': False, 'error': f'不支持的文件类型: {file_ext}'}

        # 3. MIME类型检查
        if not self.validate_mime_type(file_data.content_type, file_type):
            return {'valid': False, 'error': 'MIME类型与文件扩展名不匹配'}

        # 4. 用户上传配额检查
        quota_check = self.check_user_quota(user_id, file_data.size)
        if not quota_check['valid']:
            return quota_check

        # 5. 文件内容安全检查
        security_check = self.security_scan(file_data)
        if not security_check['valid']:
            return security_check

        return {'valid': True}

    def security_scan(self, file_data):
        """文件安全扫描"""
        # 1. 检查文件签名
        if not self.verify_file_signature(file_data):
            return {'valid': False, 'error': '文件签名验证失败'}

        # 2. 扫描恶意代码
        if self.contains_malicious_content(file_data):
            return {'valid': False, 'error': '检测到恶意内容'}

        # 3. 检查文件头信息
        if not self.validate_file_header(file_data):
            return {'valid': False, 'error': '文件头信息无效'}

        return {'valid': True}
```

### 存储系统集成

#### 多云存储支持
```python
class StorageManager:
    def __init__(self):
        self.providers = {
            'local': LocalStorageProvider(),
            's3': S3StorageProvider(),
            'oss': OSSStorageProvider(),
            'qiniu': QiniuStorageProvider()
        }

    def save_file(self, file_data, file_path, provider='local'):
        """保存文件到指定存储提供商"""
        storage_provider = self.providers.get(provider)
        if not storage_provider:
            raise ValueError(f"不支持的存储提供商: {provider}")

        try:
            result = storage_provider.upload(file_data, file_path)
            return {
                'success': True,
                'file_path': result['file_path'],
                'url': result.get('url'),
                'storage_info': result.get('storage_info', {})
            }
        except Exception as e:
            logger.error(f"文件上传失败: {str(e)}")
            return {'success': False, 'error': str(e)}
```

## Dependencies

- [ ] Task 001: 后端基础架构
- [ ] 用户管理模块 (上传权限和配额)
- [ ] 云存储服务配置 (AWS S3, 阿里云OSS等)
- [ ] Celery异步任务处理

## Effort Estimate

- Size: L
- Hours: 24小时
- Parallel: true

## Definition of Done

- [ ] 所有文件上传API接口实现完成
- [ ] 断点续传功能正常工作
- [ ] 文件验证和安全检查有效
- [ ] 多云存储支持正常
- [ ] 上传性能满足要求 (100MB文件<30s)
- [ ] 单元测试覆盖率达到90%
- [ ] 集成测试通过
- [ ] API文档更新完成

## Implementation Notes

### Service层设计
```python
class MediaUploadService:
    def upload_single_file(self, file_data, user_id, options):
        """单文件上传"""
        pass

    def upload_multiple_files(self, files, user_id, options):
        """批量文件上传"""
        pass

    def init_chunked_upload(self, file_info, user_id):
        """初始化分块上传"""
        pass

    def upload_chunk(self, session_id, chunk_data, chunk_index):
        """上传文件分块"""
        pass

    def complete_chunked_upload(self, session_id):
        """完成分块上传"""
        pass
```

### 缓存策略
- `upload:session:{id}`: 上传会话信息 (TTL: 24小时)
- `upload:quota:{user_id}`: 用户上传配额 (TTL: 1小时)
- `upload:progress:{session_id}`: 上传进度 (TTL: 1小时)

### 性能优化
- 并行分块上传
- 文件去重检查
- CDN加速上传
- 压缩传输优化

### 错误处理
- 400: 文件参数无效
- 413: 文件过大
- 415: 不支持的文件类型
- 429: 上传频率过高
- 507: 存储空间不足

### 安全考虑
- 文件上传频率限制
- 恶意文件扫描
- 文件访问权限控制
- 上传日志和审计