---
name: Markdown编辑器支持
status: backlog
created: 2025-09-15T02:51:00Z
github: https://github.com/rcnn/sharestack/issues/46
depends_on: [001, 34]
parallel: true
conflicts_with: []
---

# Task: Markdown编辑器支持

## Description

实现完整的Markdown编辑器后端支持，包括Markdown解析、富文本编辑功能、语法高亮支持、编辑器状态同步等。为内容创作提供专业的Markdown编辑体验。

## Acceptance Criteria

- [ ] 实现Markdown解析API
- [ ] 实现富文本编辑功能
- [ ] 实现语法高亮支持
- [ ] 实现编辑器状态同步
- [ ] 实现实时预览功能
- [ ] 实现文档大纲生成
- [ ] 实现图片上传集成
- [ ] 编写完整的测试用例

## Technical Details

### Markdown处理核心

#### Markdown解析器
```python
import markdown
from markdown.extensions import codehilite, toc, tables, fenced_code
from pygments import highlight
from pygments.lexers import get_lexer_by_name
from pygments.formatters import HtmlFormatter
import bleach

class MarkdownProcessor:
    def __init__(self):
        self.markdown_instance = markdown.Markdown(
            extensions=[
                'codehilite',
                'toc',
                'tables',
                'fenced_code',
                'nl2br',
                'sane_lists'
            ],
            extension_configs={
                'codehilite': {
                    'css_class': 'highlight',
                    'use_pygments': True,
                    'noclasses': False
                },
                'toc': {
                    'anchorlink': True,
                    'permalink': True
                }
            }
        )
        
        # 允许的HTML标签和属性
        self.allowed_tags = [
            'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
            'p', 'br', 'strong', 'em', 'u', 's', 'del',
            'blockquote', 'code', 'pre',
            'ul', 'ol', 'li',
            'a', 'img',
            'table', 'thead', 'tbody', 'tr', 'th', 'td',
            'div', 'span'
        ]
        
        self.allowed_attributes = {
            'a': ['href', 'title', 'rel'],
            'img': ['src', 'alt', 'title', 'width', 'height'],
            'code': ['class'],
            'pre': ['class'],
            'div': ['class', 'id'],
            'span': ['class'],
            'h1': ['id'], 'h2': ['id'], 'h3': ['id'],
            'h4': ['id'], 'h5': ['id'], 'h6': ['id']
        }

    def parse_markdown(self, markdown_text):
        """解析Markdown文本为HTML"""
        try:
            # 重置解析器状态
            self.markdown_instance.reset()
            
            # 解析Markdown
            html_content = self.markdown_instance.convert(markdown_text)
            
            # 获取目录
            toc_html = getattr(self.markdown_instance, 'toc', '')
            
            # 清理HTML，防止XSS攻击
            clean_html = bleach.clean(
                html_content,
                tags=self.allowed_tags,
                attributes=self.allowed_attributes,
                strip=True
            )
            
            return {
                'html': clean_html,
                'toc': toc_html,
                'word_count': self._count_words(markdown_text),
                'reading_time': self._estimate_reading_time(markdown_text)
            }
            
        except Exception as e:
            logger.error(f"Markdown解析失败: {str(e)}")
            return {
                'html': '<p>解析错误</p>',
                'toc': '',
                'word_count': 0,
                'reading_time': 0
            }

    def _count_words(self, text):
        """统计字数"""
        import re
        # 移除Markdown语法标记
        clean_text = re.sub(r'[#*`\[\]()_~]', '', text)
        # 统计中文字符和英文单词
        chinese_chars = len(re.findall(r'[\u4e00-\u9fff]', clean_text))
        english_words = len(re.findall(r'\b\w+\b', clean_text))
        return chinese_chars + english_words

    def _estimate_reading_time(self, text):
        """估算阅读时间（分钟）"""
        word_count = self._count_words(text)
        # 假设平均阅读速度为300字/分钟
        reading_time = max(1, word_count // 300)
        return reading_time

    def extract_summary(self, markdown_text, max_length=200):
        """提取文章摘要"""
        # 解析为纯文本
        html = self.parse_markdown(markdown_text)['html']
        import re
        text = re.sub(r'<[^>]+>', '', html)
        
        # 截取指定长度
        if len(text) <= max_length:
            return text
        
        # 在句号处截断
        truncated = text[:max_length]
        last_period = truncated.rfind('。')
        last_exclamation = truncated.rfind('！')
        last_question = truncated.rfind('？')
        
        best_end = max(last_period, last_exclamation, last_question)
        
        if best_end > max_length * 0.7:  # 如果截断点合理
            return text[:best_end + 1]
        else:
            return truncated + '...'
```

### API接口实现

#### Markdown处理接口
- **POST /api/v1/markdown/parse**
  - 请求体: markdown_text
  - 解析Markdown文本为HTML
  - 响应: 200 OK + 解析结果

- **POST /api/v1/markdown/preview**
  - 请求体: markdown_text
  - 实时预览Markdown内容
  - 响应: 200 OK + HTML预览

- **POST /api/v1/markdown/toc**
  - 请求体: markdown_text
  - 生成文档目录
  - 响应: 200 OK + 目录结构

#### 编辑器状态同步
- **POST /api/v1/editor/save-state**
  - 请求体: content_id, cursor_position, scroll_position, selected_text
  - 保存编辑器状态
  - 响应: 200 OK

- **GET /api/v1/editor/load-state/{content_id}**
  - 加载编辑器状态
  - 响应: 200 OK + 编辑器状态

### 实时协作编辑

#### WebSocket实时通信
```python
from channels.generic.websocket import AsyncWebsocketConsumer
import json

class MarkdownEditorConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        self.content_id = self.scope['url_route']['kwargs']['content_id']
        self.room_group_name = f'editor_{self.content_id}'
        
        # 加入编辑器房间
        await self.channel_layer.group_add(
            self.room_group_name,
            self.channel_name
        )
        
        await self.accept()
        
        # 发送当前编辑者列表
        await self.send_editor_list()

    async def disconnect(self, close_code):
        # 离开编辑器房间
        await self.channel_layer.group_discard(
            self.room_group_name,
            self.channel_name
        )

    async def receive(self, text_data):
        data = json.loads(text_data)
        message_type = data['type']
        
        if message_type == 'text_change':
            # 文本变更
            await self.handle_text_change(data)
        elif message_type == 'cursor_move':
            # 光标移动
            await self.handle_cursor_move(data)
        elif message_type == 'selection_change':
            # 选中文本变更
            await self.handle_selection_change(data)

    async def handle_text_change(self, data):
        """处理文本变更"""
        # 广播给其他编辑者
        await self.channel_layer.group_send(
            self.room_group_name,
            {
                'type': 'text_change_message',
                'change': data['change'],
                'user_id': data['user_id'],
                'timestamp': data['timestamp']
            }
        )
        
        # 保存变更历史
        await self.save_change_history(data)

    async def text_change_message(self, event):
        """发送文本变更消息"""
        await self.send(text_data=json.dumps({
            'type': 'text_change',
            'change': event['change'],
            'user_id': event['user_id'],
            'timestamp': event['timestamp']
        }))

    async def save_change_history(self, data):
        """保存变更历史"""
        # 异步保存到数据库
        from channels.db import database_sync_to_async
        
        @database_sync_to_async
        def save_to_db():
            EditHistoryRepository.create({
                'content_id': self.content_id,
                'user_id': data['user_id'],
                'change_type': data['change']['type'],
                'change_data': data['change'],
                'timestamp': data['timestamp']
            })
        
        await save_to_db()
```

### 编辑器增强功能

#### 语法高亮服务
```python
class SyntaxHighlightService:
    def get_highlight_config(self, language='markdown'):
        """获取语法高亮配置"""
        configs = {
            'markdown': {
                'keywords': ['#', '##', '###', '####', '#####', '######'],
                'emphasis': ['*', '_', '**', '__'],
                'links': ['[', ']', '(', ')'],
                'code': ['`', '```'],
                'lists': ['-', '+', '*', '1.', '2.', '3.']
            },
            'javascript': {
                'keywords': ['function', 'var', 'let', 'const', 'if', 'else', 'for', 'while'],
                'strings': ['"', "'", '`'],
                'comments': ['//', '/*', '*/']
            },
            'python': {
                'keywords': ['def', 'class', 'if', 'else', 'for', 'while', 'import', 'from'],
                'strings': ['"', "'", '"""', "'''"],
                'comments': ['#']
            }
        }
        
        return configs.get(language, configs['markdown'])

    def analyze_document_structure(self, markdown_text):
        """分析文档结构"""
        import re
        
        structure = {
            'headings': [],
            'code_blocks': [],
            'links': [],
            'images': [],
            'tables': []
        }
        
        lines = markdown_text.split('\n')
        
        for i, line in enumerate(lines):
            # 标题
            heading_match = re.match(r'^(#{1,6})\s+(.+)$', line)
            if heading_match:
                level = len(heading_match.group(1))
                text = heading_match.group(2)
                structure['headings'].append({
                    'level': level,
                    'text': text,
                    'line': i + 1
                })
            
            # 代码块
            if line.strip().startswith('```'):
                language = line.strip()[3:].strip()
                structure['code_blocks'].append({
                    'language': language,
                    'line': i + 1
                })
            
            # 链接
            link_matches = re.findall(r'\[([^\]]+)\]\(([^)]+)\)', line)
            for text, url in link_matches:
                structure['links'].append({
                    'text': text,
                    'url': url,
                    'line': i + 1
                })
            
            # 图片
            image_matches = re.findall(r'!\[([^\]]*)\]\(([^)]+)\)', line)
            for alt, src in image_matches:
                structure['images'].append({
                    'alt': alt,
                    'src': src,
                    'line': i + 1
                })
            
            # 表格
            if '|' in line and line.strip().startswith('|'):
                structure['tables'].append({
                    'line': i + 1
                })
        
        return structure
```

### 图片上传集成

#### 编辑器图片上传
```python
class EditorImageService:
    def upload_editor_image(self, image_file, user_id, content_id=None):
        """编辑器图片上传"""
        # 验证图片
        if not self._validate_image(image_file):
            raise ValidationError("无效的图片文件")
        
        # 上传图片
        file_record = MediaUploadService.upload_single_file(
            image_file, user_id, {
                'content_id': content_id,
                'is_public': True,
                'category': 'editor_image'
            }
        )
        
        # 生成Markdown图片语法
        markdown_syntax = f"![{file_record.original_filename}]({file_record.cdn_url})"
        
        return {
            'file_id': file_record.id,
            'url': file_record.cdn_url,
            'markdown': markdown_syntax,
            'size': file_record.file_size,
            'dimensions': file_record.metadata.get('dimensions', {})
        }
    
    def _validate_image(self, image_file):
        """验证图片文件"""
        allowed_types = ['image/jpeg', 'image/png', 'image/gif', 'image/webp']
        max_size = 5 * 1024 * 1024  # 5MB
        
        if image_file.content_type not in allowed_types:
            return False
        
        if image_file.size > max_size:
            return False
        
        return True

    def paste_image_upload(self, image_data, user_id, content_id=None):
        """处理粘贴图片上传"""
        import base64
        from io import BytesIO
        
        # 解析base64图片数据
        if image_data.startswith('data:image/'):
            header, data = image_data.split(',', 1)
            image_bytes = base64.b64decode(data)
            
            # 创建临时文件对象
            image_file = BytesIO(image_bytes)
            
            # 上传图片
            return self.upload_editor_image(image_file, user_id, content_id)
        
        raise ValidationError("无效的图片数据")
```

### 文档统计和分析

```python
class DocumentAnalyticsService:
    def analyze_document(self, markdown_text):
        """分析文档统计信息"""
        processor = MarkdownProcessor()
        result = processor.parse_markdown(markdown_text)
        structure = SyntaxHighlightService().analyze_document_structure(markdown_text)
        
        return {
            'word_count': result['word_count'],
            'reading_time': result['reading_time'],
            'character_count': len(markdown_text),
            'paragraph_count': len([p for p in markdown_text.split('\n\n') if p.strip()]),
            'heading_count': len(structure['headings']),
            'image_count': len(structure['images']),
            'link_count': len(structure['links']),
            'code_block_count': len(structure['code_blocks']),
            'table_count': len(structure['tables']),
            'complexity_score': self._calculate_complexity(structure)
        }
    
    def _calculate_complexity(self, structure):
        """计算文档复杂度评分"""
        score = 0
        
        # 标题结构评分
        score += len(structure['headings']) * 2
        
        # 代码块评分
        score += len(structure['code_blocks']) * 3
        
        # 表格评分
        score += len(structure['tables']) * 4
        
        # 图片和链接评分
        score += len(structure['images']) * 1
        score += len(structure['links']) * 1
        
        return min(score, 100)  # 最高100分
```

## Dependencies

- [ ] Task 001: 后端基础架构
- [ ] Task 013: 内容核心CRUD系统
- [ ] Task 020: 文件上传系统 (图片上传)
- [ ] Python-Markdown库
- [ ] Pygments语法高亮库
- [ ] Django Channels (WebSocket支持)

## Effort Estimate

- Size: L
- Hours: 18小时
- Parallel: true

## Definition of Done

- [ ] 所有Markdown处理API接口实现完成
- [ ] Markdown解析功能正确
- [ ] 实时协作编辑功能正常
- [ ] 语法高亮支持完整
- [ ] 图片上传集成正常
- [ ] 文档统计功能准确
- [ ] WebSocket连接稳定
- [ ] 单元测试覆盖率达到90%
- [ ] API文档更新完成

## Implementation Notes

### Service层设计
```python
class MarkdownEditorService:
    def parse_markdown(self, markdown_text, options=None):
        """解析Markdown"""
        pass

    def save_editor_state(self, content_id, user_id, state):
        """保存编辑器状态"""
        pass

    def upload_editor_image(self, image_file, user_id, content_id):
        """上传编辑器图片"""
        pass

    def analyze_document(self, markdown_text):
        """分析文档"""
        pass
```

### 缓存策略
- `markdown:parsed:{hash}`: 解析结果缓存 (TTL: 1小时)
- `editor:state:{content_id}:{user_id}`: 编辑器状态 (TTL: 24小时)
- `doc:analysis:{hash}`: 文档分析结果 (TTL: 2小时)

### 性能优化
- Markdown解析结果缓存
- 实时预览防抖动
- WebSocket连接池管理
- 大文档分块处理

### 错误处理
- 400: Markdown语法错误
- 413: 文档过大
- 422: 编辑器状态无效
- 429: 编辑频率过高

### 安全考虑
- HTML内容清理防XSS
- 协作编辑权限控制
- 图片上传安全检查
- WebSocket连接验证