---
name: 内容预览和发布流程
status: backlog
created: 2025-09-15T02:51:00Z
github: https://github.com/rcnn/sharestack/issues/47
depends_on: [34, 46]
parallel: true
conflicts_with: []
---

# Task: 内容预览和发布流程

## Description

实现完整的内容预览和发布流程系统，包括实时预览、发布前验证、发布流程管理、发布状态通知等功能。为内容创作者提供专业的发布体验。

## Acceptance Criteria

- [ ] 实现内容预览API
- [ ] 实现发布前验证
- [ ] 实现发布流程管理
- [ ] 实现发布状态通知
- [ ] 实现SEO优化支持
- [ ] 实现社交媒体集成
- [ ] 实现发布统计和分析
- [ ] 编写完整的测试用例

## Technical Details

### 内容预览系统

#### 预览数据模型
```sql
CREATE TABLE content_previews (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    content_id BIGINT NOT NULL,
    preview_token VARCHAR(64) NOT NULL UNIQUE,
    preview_type ENUM('draft', 'scheduled', 'shared') DEFAULT 'draft',
    preview_config JSON, -- 预览配置
    expires_at TIMESTAMP NOT NULL,
    view_count INT DEFAULT 0,
    created_by BIGINT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_preview_token (preview_token),
    INDEX idx_content_id (content_id),
    INDEX idx_expires_at (expires_at),
    FOREIGN KEY (content_id) REFERENCES contents(id) ON DELETE CASCADE,
    FOREIGN KEY (created_by) REFERENCES users(id)
);
```

#### 预览服务实现
```python
class ContentPreviewService:
    def generate_preview(self, content_id, user_id, preview_type='draft', config=None):
        """生成内容预览"""
        content = ContentRepository.get_by_id(content_id)
        if not content or content.author_id != user_id:
            raise PermissionError("无权限预览此内容")
        
        # 生成预览token
        preview_token = self._generate_preview_token()
        
        # 设置过期时间
        expires_at = datetime.now() + timedelta(hours=24)  # 24小时后过期
        
        # 创建预览记录
        preview = ContentPreviewRepository.create({
            'content_id': content_id,
            'preview_token': preview_token,
            'preview_type': preview_type,
            'preview_config': config or {},
            'expires_at': expires_at,
            'created_by': user_id
        })
        
        # 生成预览URL
        preview_url = f"{settings.FRONTEND_URL}/preview/{preview_token}"
        
        return {
            'preview_id': preview.id,
            'preview_token': preview_token,
            'preview_url': preview_url,
            'expires_at': expires_at.isoformat(),
            'config': config
        }
    
    def get_preview_content(self, preview_token):
        """获取预览内容"""
        preview = ContentPreviewRepository.get_by_token(preview_token)
        if not preview:
            raise NotFoundError("预览链接不存在")
        
        if preview.expires_at < datetime.now():
            raise ExpiredError("预览链接已过期")
        
        # 获取内容
        content = ContentRepository.get_by_id(preview.content_id)
        if not content:
            raise NotFoundError("内容不存在")
        
        # 更新预览次数
        preview.view_count += 1
        ContentPreviewRepository.update(preview)
        
        # 处理内容渲染
        rendered_content = self._render_content_for_preview(content, preview.preview_config)
        
        return {
            'content': rendered_content,
            'preview_info': {
                'type': preview.preview_type,
                'created_at': preview.created_at.isoformat(),
                'view_count': preview.view_count
            }
        }
    
    def _render_content_for_preview(self, content, config):
        """渲染预览内容"""
        # 解析Markdown
        if content.content_type == 'article':
            markdown_processor = MarkdownProcessor()
            parsed_result = markdown_processor.parse_markdown(content.content)
            
            rendered_content = {
                'id': content.id,
                'title': content.title,
                'content': parsed_result['html'],
                'toc': parsed_result['toc'],
                'summary': content.summary,
                'author': {
                    'id': content.author.id,
                    'username': content.author.username,
                    'avatar': content.author.avatar_url
                },
                'metadata': {
                    'word_count': parsed_result['word_count'],
                    'reading_time': parsed_result['reading_time'],
                    'created_at': content.created_at.isoformat(),
                    'updated_at': content.updated_at.isoformat()
                }
            }
        else:
            # 其他类型内容的处理
            rendered_content = {
                'id': content.id,
                'title': content.title,
                'content': content.content,
                'content_type': content.content_type,
                'summary': content.summary
            }
        
        # 应用预览配置
        if config.get('hide_author'):
            rendered_content.pop('author', None)
        
        if config.get('watermark'):
            rendered_content['watermark'] = config['watermark']
        
        return rendered_content
```

### 发布前验证系统

#### 内容验证器
```python
class ContentValidator:
    def validate_before_publish(self, content_id, user_id):
        """发布前验证"""
        content = ContentRepository.get_by_id(content_id)
        if not content:
            raise NotFoundError("内容不存在")
        
        if content.author_id != user_id:
            raise PermissionError("无权限发布此内容")
        
        validation_results = {
            'can_publish': True,
            'warnings': [],
            'errors': [],
            'suggestions': []
        }
        
        # 基本信息验证
        self._validate_basic_info(content, validation_results)
        
        # 内容质量验证
        self._validate_content_quality(content, validation_results)
        
        # SEO验证
        self._validate_seo(content, validation_results)
        
        # 媒体文件验证
        self._validate_media_files(content, validation_results)
        
        # 权限验证
        self._validate_permissions(content, validation_results)
        
        # 如果有错误，不能发布
        if validation_results['errors']:
            validation_results['can_publish'] = False
        
        return validation_results
    
    def _validate_basic_info(self, content, results):
        """验证基本信息"""
        if not content.title or len(content.title.strip()) < 5:
            results['errors'].append("标题不能少于5个字符")
        
        if not content.content or len(content.content.strip()) < 100:
            results['errors'].append("内容不能少于100个字符")
        
        if not content.summary:
            results['warnings'].append("建议添加内容摘要")
        elif len(content.summary) > 500:
            results['warnings'].append("摘要过长，建议控制在500字以内")
    
    def _validate_content_quality(self, content, results):
        """验证内容质量"""
        if content.content_type == 'article':
            # 分析Markdown内容
            processor = MarkdownProcessor()
            parsed_result = processor.parse_markdown(content.content)
            
            # 检查字数
            if parsed_result['word_count'] < 300:
                results['warnings'].append("文章较短，建议至少300字")
            
            # 检查标题结构
            structure = SyntaxHighlightService().analyze_document_structure(content.content)
            if not structure['headings']:
                results['suggestions'].append("建议添加标题来优化文章结构")
    
    def _validate_seo(self, content, results):
        """验证SEO"""
        # 标题长度
        if len(content.title) > 60:
            results['warnings'].append("标题过长，对SEO不利")
        
        # 摘要长度
        if content.summary and len(content.summary) > 160:
            results['warnings'].append("摘要过长，建议控制在160字以内")
        
        # 检查关键词
        if not self._has_keywords(content):
            results['suggestions'].append("建议添加相关标签或关键词")
    
    def _validate_media_files(self, content, results):
        """验证媒体文件"""
        # 检查图片alt属性
        import re
        image_matches = re.findall(r'!\[([^\]]*)\]\([^)]+\)', content.content or '')
        
        images_without_alt = [img for img in image_matches if not img[0].strip()]
        if images_without_alt:
            results['warnings'].append(f"有{len(images_without_alt)}张图片缺少alt属性")
```

### 发布流程管理

#### 发布流程定义
```python
class PublishingWorkflowService:
    def create_publish_workflow(self, content_id, user_id, workflow_config=None):
        """创建发布流程"""
        # 验证内容
        validation_result = ContentValidator().validate_before_publish(content_id, user_id)
        if not validation_result['can_publish']:
            raise ValidationError("内容验证失败", validation_result['errors'])
        
        # 创建流程实例
        workflow = PublishWorkflowRepository.create({
            'content_id': content_id,
            'user_id': user_id,
            'workflow_config': workflow_config or self._get_default_workflow(),
            'current_step': 0,
            'status': 'in_progress',
            'validation_result': validation_result
        })
        
        # 启动流程
        self._execute_workflow_step.delay(workflow.id)
        
        return workflow
    
    def _get_default_workflow(self):
        """获取默认发布流程"""
        return {
            'steps': [
                {
                    'name': 'pre_publish_validation',
                    'title': '发布前验证',
                    'type': 'validation',
                    'config': {}
                },
                {
                    'name': 'content_processing',
                    'title': '内容处理',
                    'type': 'processing',
                    'config': {
                        'generate_summary': True,
                        'extract_keywords': True,
                        'optimize_images': True
                    }
                },
                {
                    'name': 'seo_optimization',
                    'title': 'SEO优化',
                    'type': 'seo',
                    'config': {
                        'generate_meta_tags': True,
                        'create_sitemap_entry': True
                    }
                },
                {
                    'name': 'publish_content',
                    'title': '发布内容',
                    'type': 'publish',
                    'config': {}
                },
                {
                    'name': 'post_publish_tasks',
                    'title': '发布后任务',
                    'type': 'post_publish',
                    'config': {
                        'send_notifications': True,
                        'update_search_index': True,
                        'generate_social_cards': True
                    }
                }
            ],
            'settings': {
                'auto_retry': True,
                'max_retries': 3,
                'retry_delay': 60
            }
        }
    
    @celery.task
    def _execute_workflow_step(self, workflow_id):
        """执行流程步骤"""
        workflow = PublishWorkflowRepository.get_by_id(workflow_id)
        if not workflow or workflow.status != 'in_progress':
            return
        
        steps = workflow.workflow_config['steps']
        current_step_index = workflow.current_step
        
        if current_step_index >= len(steps):
            # 流程完成
            self._complete_workflow(workflow)
            return
        
        current_step = steps[current_step_index]
        
        try:
            # 执行当前步骤
            step_result = self._execute_step(workflow, current_step)
            
            # 更新进度
            workflow.current_step += 1
            workflow.step_results = workflow.step_results or []
            workflow.step_results.append(step_result)
            PublishWorkflowRepository.update(workflow)
            
            # 继续下一步
            self._execute_workflow_step.delay(workflow_id)
            
        except Exception as e:
            # 步骤失败
            self._handle_step_failure(workflow, current_step, str(e))
    
    def _execute_step(self, workflow, step):
        """执行具体步骤"""
        step_type = step['type']
        
        if step_type == 'validation':
            return self._execute_validation_step(workflow, step)
        elif step_type == 'processing':
            return self._execute_processing_step(workflow, step)
        elif step_type == 'seo':
            return self._execute_seo_step(workflow, step)
        elif step_type == 'publish':
            return self._execute_publish_step(workflow, step)
        elif step_type == 'post_publish':
            return self._execute_post_publish_step(workflow, step)
        else:
            raise ValueError(f"不支持的步骤类型: {step_type}")
```

### SEO优化支持

#### SEO元数据生成
```python
class SEOOptimizationService:
    def generate_meta_tags(self, content):
        """生成SEO元数据标签"""
        meta_tags = {
            'title': self._optimize_title(content.title),
            'description': self._generate_meta_description(content),
            'keywords': self._extract_keywords(content),
            'author': content.author.username,
            'og_tags': self._generate_og_tags(content),
            'twitter_tags': self._generate_twitter_tags(content),
            'structured_data': self._generate_structured_data(content)
        }
        
        return meta_tags
    
    def _optimize_title(self, title):
        """优化标题"""
        # 确保标题长度合适
        if len(title) > 60:
            return title[:57] + '...'
        return title
    
    def _generate_meta_description(self, content):
        """生成meta description"""
        if content.summary:
            description = content.summary
        else:
            # 从内容中提取
            processor = MarkdownProcessor()
            description = processor.extract_summary(content.content, max_length=160)
        
        # 确保长度合适
        if len(description) > 160:
            description = description[:157] + '...'
        
        return description
    
    def _extract_keywords(self, content):
        """提取关键词"""
        keywords = []
        
        # 从标签获取
        if hasattr(content, 'tags') and content.tags:
            keywords.extend(content.tags)
        
        # 从分类获取
        if hasattr(content, 'categories'):
            keywords.extend([cat.name for cat in content.categories])
        
        # 从内容中提取高频词
        content_keywords = self._extract_content_keywords(content.content)
        keywords.extend(content_keywords[:5])  # 最多5个
        
        return list(set(keywords))[:10]  # 去重，最多10个
    
    def _generate_og_tags(self, content):
        """生成Open Graph标签"""
        og_tags = {
            'og:type': 'article',
            'og:title': content.title,
            'og:description': self._generate_meta_description(content),
            'og:url': f"{settings.SITE_URL}/content/{content.id}",
            'og:site_name': settings.SITE_NAME,
            'article:author': content.author.username,
            'article:published_time': content.created_at.isoformat(),
            'article:modified_time': content.updated_at.isoformat()
        }
        
        # 添加图片
        featured_image = self._get_featured_image(content)
        if featured_image:
            og_tags['og:image'] = featured_image
            og_tags['og:image:alt'] = content.title
        
        return og_tags
    
    def _generate_structured_data(self, content):
        """生成结构化数据"""
        structured_data = {
            "@context": "https://schema.org",
            "@type": "Article",
            "headline": content.title,
            "description": self._generate_meta_description(content),
            "author": {
                "@type": "Person",
                "name": content.author.username
            },
            "datePublished": content.created_at.isoformat(),
            "dateModified": content.updated_at.isoformat(),
            "publisher": {
                "@type": "Organization",
                "name": settings.SITE_NAME,
                "logo": {
                    "@type": "ImageObject",
                    "url": f"{settings.SITE_URL}/static/logo.png"
                }
            }
        }
        
        # 添加图片
        featured_image = self._get_featured_image(content)
        if featured_image:
            structured_data["image"] = featured_image
        
        return structured_data
```

### 发布状态通知

#### 通知系统集成
```python
class PublishNotificationService:
    def send_publish_notifications(self, content, workflow_result):
        """发送发布通知"""
        # 发送给作者
        self._notify_author(content, workflow_result)
        
        # 发送给订阅者
        self._notify_subscribers(content)
        
        # 社交媒体通知
        self._notify_social_media(content)
        
        # 管理员通知
        if content.is_featured:
            self._notify_admins(content)
    
    def _notify_author(self, content, workflow_result):
        """通知作者"""
        notification_data = {
            'user_id': content.author_id,
            'type': 'content_published',
            'title': '内容发布成功',
            'message': f'您的内容《{content.title}》已成功发布',
            'data': {
                'content_id': content.id,
                'content_url': f"/content/{content.id}",
                'workflow_result': workflow_result
            }
        }
        
        NotificationService.send_notification(notification_data)
    
    def _notify_subscribers(self, content):
        """通知订阅者"""
        # 获取作者的订阅者
        subscribers = UserFollowRepository.get_followers(content.author_id)
        
        for subscriber in subscribers:
            # 检查通知设置
            if self._should_notify_subscriber(subscriber, content):
                notification_data = {
                    'user_id': subscriber.id,
                    'type': 'new_content_from_following',
                    'title': '新内容通知',
                    'message': f'{content.author.username}发布了新内容《{content.title}》',
                    'data': {
                        'content_id': content.id,
                        'author_id': content.author_id,
                        'content_url': f"/content/{content.id}"
                    }
                }
                
                NotificationService.send_notification(notification_data)
```

## Dependencies

- [ ] Task 013: 内容核心CRUD系统
- [ ] Task 025: Markdown编辑器支持
- [ ] 通知系统
- [ ] Celery异步任务处理
- [ ] SEO优化工具

## Effort Estimate

- Size: L
- Hours: 20小时
- Parallel: true

## Definition of Done

- [ ] 所有预览和发布API接口实现完成
- [ ] 内容验证功能正确
- [ ] 发布流程管理稳定
- [ ] SEO优化支持完整
- [ ] 通知系统集成正常
- [ ] 预览功能正常工作
- [ ] 发布流程性能满足要求
- [ ] 单元测试覆盖率达到90%
- [ ] API文档更新完成

## Implementation Notes

### Service层设计
```python
class ContentPublishingService:
    def create_preview(self, content_id, user_id, config):
        """创建预览"""
        pass

    def validate_content(self, content_id, user_id):
        """验证内容"""
        pass

    def start_publish_workflow(self, content_id, user_id, config):
        """启动发布流程"""
        pass

    def get_workflow_status(self, workflow_id):
        """获取流程状态"""
        pass
```

### 缓存策略
- `preview:{token}`: 预览内容缓存 (TTL: 24小时)
- `validation:{content_id}`: 验证结果缓存 (TTL: 1小时)
- `seo:meta:{content_id}`: SEO元数据缓存 (TTL: 7天)

### 性能优化
- 预览内容缓存
- 异步流程处理
- SEO数据缓存
- 批量通知发送

### 错误处理
- 400: 验证参数无效
- 403: 无发布权限
- 410: 预览链接已过期
- 422: 内容验证失败

### 安全考虑
- 预览链接访问控制
- 发布权限验证
- SEO数据清理防XSS
- 敏感内容检测